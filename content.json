{"meta":{"title":"wenlwei","subtitle":"wenlweiの博客","description":"本科","author":"wenlwei","url":"https://wenlwei.github.io","root":"/"},"pages":[{"title":"404","date":"2019-08-10T08:41:10.000Z","updated":"2022-01-29T10:33:07.858Z","comments":true,"path":"404.html","permalink":"https://wenlwei.github.io/404.html","excerpt":"","text":""},{"title":"","date":"2022-01-29T10:33:08.046Z","updated":"2022-01-29T10:33:08.046Z","comments":true,"path":"google1xxxxxxx0.html","permalink":"https://wenlwei.github.io/google1xxxxxxx0.html","excerpt":"","text":"google-site-verification: google110e5e5e14c8dcf0.html"},{"title":"","date":"2022-01-29T10:33:08.046Z","updated":"2022-01-29T10:33:08.046Z","comments":true,"path":"baidu_verify_xxxxxxx.html","permalink":"https://wenlwei.github.io/baidu_verify_xxxxxxx.html","excerpt":"","text":"wvlc3L96QK"},{"title":"archives","date":"2019-10-24T16:00:00.000Z","updated":"2022-01-29T10:33:08.046Z","comments":true,"path":"archives/index.html","permalink":"https://wenlwei.github.io/archives/index.html","excerpt":"","text":""},{"title":"放松一下","date":"2019-08-10T08:41:10.000Z","updated":"2022-01-29T10:33:07.874Z","comments":true,"path":"List/index.html","permalink":"https://wenlwei.github.io/List/index.html","excerpt":"","text":"影音资源共享"},{"title":"about","date":"2019-10-24T16:00:00.000Z","updated":"2022-01-29T10:33:08.046Z","comments":true,"path":"about/index.html","permalink":"https://wenlwei.github.io/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-10-24T16:00:00.000Z","updated":"2022-01-29T10:33:08.046Z","comments":true,"path":"categories/index.html","permalink":"https://wenlwei.github.io/categories/index.html","excerpt":"","text":""},{"title":"统计","date":"2020-10-31T02:11:28.000Z","updated":"2022-01-29T10:33:08.046Z","comments":true,"path":"census/index.html","permalink":"https://wenlwei.github.io/census/index.html","excerpt":"","text":""},{"title":"留言板","date":"2019-10-24T16:00:00.000Z","updated":"2022-01-29T12:39:22.868Z","comments":true,"path":"contact/index.html","permalink":"https://wenlwei.github.io/contact/index.html","excerpt":"","text":"畅所欲言 在这里可以留下你的足迹，欢迎在下方留言，欢迎交换友链，一起交流学习！ 友链 wenlweiの友链信息 博客名称: wenlweiの博客 博客网址: wenlwei 博客头像: https://s4.ax1x.com/2022/01/29/HpyLa4.jpg 博客介绍: The harder you work, the luckier you will be"},{"title":"友链","date":"2019-07-19T08:42:10.000Z","updated":"2022-01-29T10:33:08.046Z","comments":true,"path":"friends/index.html","permalink":"https://wenlwei.github.io/friends/index.html","excerpt":"","text":""},{"title":"资源分享","date":"2019-07-19T08:40:27.000Z","updated":"2022-01-29T10:33:08.062Z","comments":true,"path":"resource/index.html","permalink":"https://wenlwei.github.io/resource/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-07-19T08:40:27.000Z","updated":"2022-01-29T10:33:08.062Z","comments":true,"path":"tags/index.html","permalink":"https://wenlwei.github.io/tags/index.html","excerpt":"","text":""},{"title":"视频","date":"2019-08-10T08:41:10.000Z","updated":"2022-01-29T10:33:07.874Z","comments":true,"path":"List/movies/index.html","permalink":"https://wenlwei.github.io/List/movies/index.html","excerpt":"","text":""},{"title":"听听音乐","date":"2019-07-19T08:40:27.000Z","updated":"2022-01-29T10:33:07.874Z","comments":true,"path":"List/music/index.html","permalink":"https://wenlwei.github.io/List/music/index.html","excerpt":"","text":""},{"title":"听听音乐","date":"2019-07-19T08:40:27.000Z","updated":"2022-01-29T10:33:07.874Z","comments":true,"path":"List/tools/index.html","permalink":"https://wenlwei.github.io/List/tools/index.html","excerpt":"","text":""},{"title":"相册","date":"2022-01-29T10:33:07.858Z","updated":"2022-01-29T10:33:07.858Z","comments":true,"path":"List/galleries/index.html","permalink":"https://wenlwei.github.io/List/galleries/index.html","excerpt":"","text":""},{"title":"乖巧小狗","date":"2022-01-29T10:33:07.874Z","updated":"2022-01-29T10:33:07.874Z","comments":true,"path":"List/galleries/乖巧小狗/index.html","permalink":"https://wenlwei.github.io/List/galleries/%E4%B9%96%E5%B7%A7%E5%B0%8F%E7%8B%97/index.html","excerpt":"","text":""},{"title":"二次元风","date":"2022-01-29T10:33:07.874Z","updated":"2022-01-29T10:33:07.874Z","comments":true,"path":"List/galleries/二次元风/index.html","permalink":"https://wenlwei.github.io/List/galleries/%E4%BA%8C%E6%AC%A1%E5%85%83%E9%A3%8E/index.html","excerpt":"","text":""},{"title":"动漫人物","date":"2022-01-29T10:33:07.874Z","updated":"2022-01-29T10:33:07.874Z","comments":true,"path":"List/galleries/动漫人物/index.html","permalink":"https://wenlwei.github.io/List/galleries/%E5%8A%A8%E6%BC%AB%E4%BA%BA%E7%89%A9/index.html","excerpt":"","text":""},{"title":"动漫插画","date":"2022-01-29T10:33:07.874Z","updated":"2022-01-29T10:33:07.874Z","comments":true,"path":"List/galleries/动漫插画/index.html","permalink":"https://wenlwei.github.io/List/galleries/%E5%8A%A8%E6%BC%AB%E6%8F%92%E7%94%BB/index.html","excerpt":"","text":""},{"title":"动漫风景","date":"2022-01-29T10:33:07.874Z","updated":"2022-01-29T10:33:07.874Z","comments":true,"path":"List/galleries/动漫风景/index.html","permalink":"https://wenlwei.github.io/List/galleries/%E5%8A%A8%E6%BC%AB%E9%A3%8E%E6%99%AF/index.html","excerpt":"","text":""},{"title":"呆萌猫咪","date":"2022-01-29T10:33:07.874Z","updated":"2022-01-29T10:33:07.874Z","comments":true,"path":"List/galleries/呆萌猫咪/index.html","permalink":"https://wenlwei.github.io/List/galleries/%E5%91%86%E8%90%8C%E7%8C%AB%E5%92%AA/index.html","excerpt":"","text":""},{"title":"清新花卉","date":"2022-01-29T10:33:07.874Z","updated":"2022-01-29T10:33:07.874Z","comments":true,"path":"List/galleries/清新花卉/index.html","permalink":"https://wenlwei.github.io/List/galleries/%E6%B8%85%E6%96%B0%E8%8A%B1%E5%8D%89/index.html","excerpt":"","text":""},{"title":"炫酷跑车","date":"2022-01-29T10:33:07.874Z","updated":"2022-01-29T10:33:07.874Z","comments":true,"path":"List/galleries/炫酷跑车/index.html","permalink":"https://wenlwei.github.io/List/galleries/%E7%82%AB%E9%85%B7%E8%B7%91%E8%BD%A6/index.html","excerpt":"","text":""},{"title":"城市风光","date":"2022-01-29T10:33:07.874Z","updated":"2022-01-29T10:33:07.874Z","comments":true,"path":"List/galleries/城市风光/index.html","permalink":"https://wenlwei.github.io/List/galleries/%E5%9F%8E%E5%B8%82%E9%A3%8E%E5%85%89/index.html","excerpt":"","text":""},{"title":"璀璨星空","date":"2022-01-29T10:33:07.874Z","updated":"2022-01-29T10:33:07.874Z","comments":true,"path":"List/galleries/璀璨星空/index.html","permalink":"https://wenlwei.github.io/List/galleries/%E7%92%80%E7%92%A8%E6%98%9F%E7%A9%BA/index.html","excerpt":"","text":""},{"title":"甜美食品","date":"2022-01-29T10:33:07.874Z","updated":"2022-01-29T10:33:07.874Z","comments":true,"path":"List/galleries/甜美食品/index.html","permalink":"https://wenlwei.github.io/List/galleries/%E7%94%9C%E7%BE%8E%E9%A3%9F%E5%93%81/index.html","excerpt":"","text":""},{"title":"自然风景","date":"2022-01-29T10:33:07.874Z","updated":"2022-01-29T10:33:07.874Z","comments":true,"path":"List/galleries/自然风景/index.html","permalink":"https://wenlwei.github.io/List/galleries/%E8%87%AA%E7%84%B6%E9%A3%8E%E6%99%AF/index.html","excerpt":"","text":""}],"posts":[{"title":"third-day-python","slug":"third-day-python","date":"2022-03-01T03:45:36.000Z","updated":"2022-03-02T03:45:14.181Z","comments":true,"path":"posts/6f53ebbf.html","link":"","permalink":"https://wenlwei.github.io/posts/6f53ebbf.html","excerpt":"","text":"third day python列表列表（list）用于储存一串信息，索引从0开始，数据之间用逗号分割 \"\"\" 作者：wenlwei \"\"\" # 列表 list_0 = ['0', '1', '2', '3', '4', '5'] print(list_0) for i in range(6): print(list_0[i]) 运行结果： ['0', '1', '2', '3', '4', '5'] 0 1 2 3 4 5 列表常用操作\"\"\" 作者：wenlwei \"\"\" # 列表 list_0 = ['0', '1', '3', '2', '4', '5'] print(list_0) ''' for i in range(6): print(list_0[i]) ''' # 反转 list_0.reverse() for i in range(6): print(list_0[i],end=' ') print() # 升序 list_0.sort() for i in range(6): print(list_0[i],end=' ') print() # 降序 list_0.sort(reverse=True) for i in range(6): print(list_0[i],end=' ') print() 运行结果： ['0', '1', '3', '2', '4', '5'] 5 4 2 3 1 0 0 1 2 3 4 5 5 4 3 2 1 0 \"\"\" 作者：wenlwei \"\"\" # 列表 list_0 = [0, 1, 3, 2, 2, 5] print(list_0) # 获取数据第一次出现的索引 print(list_0.index(3)) # 在指定位置插入数据 list_0.insert(6, 7) print(list_0) # 在末尾添加数据 list_0.append(10) print(list_0) # 将列表1的数据添加到列表2 list_1 = [12] list_1.extend(list_0) print(list_0) print(list_1) # 删除指定索引的数据 list_0.pop(4) print(list_0) del list_0[2] # 删除末尾数据 list_0.pop() print(list_0) # 删除第一个出现的指定数据 list_1.remove(2) print(list_1) # 统计列表长度 print(len(list_1)) # 统计数据在列表中出现的次数 print(list_0.count(1)) 运行结果： [0, 1, 3, 2, 2, 5] 2 [0, 1, 3, 2, 2, 5, 7] [0, 1, 3, 2, 2, 5, 7, 10] [0, 1, 3, 2, 2, 5, 7, 10] [12, 0, 1, 3, 2, 2, 5, 7, 10] [0, 1, 3, 2, 5, 7, 10] [0, 1, 2, 5, 7] [12, 0, 1, 3, 2, 5, 7, 10] 8 1 函数名 功能 list.reverse 反转 list.sort 升序排序 list.sort(reverse=True) 降序排序 list.index(数据) 获取数据第一次出现的索引 list.insert(索引, 数据) 在指定位置插入数据 list.append() 在末尾添加数据 list2.extend(list1) 将列表1的数据添加到列表2 list.pop（索引） 删除指定索引的数据 list.pop 删除末尾数据 list.remove() 删除第一个出现的指定数据 del list[] 删除指定索引的数据 list.clear 清空列表 len() 统计列表长度 list.count() 统计数据在列表中的出现次数 列表的循环遍历（迭代遍历）\"\"\" 作者：wenlwei \"\"\" # 列表 list_0 = [0, 1, 3, 2, 2, 5] print(list_0) for i in list_0: print(i, end=' ') 运行结果： [0, 1, 3, 2, 2, 5] 0 1 3 2 2 5 元组Tuple（元组）类似列表，区别在于元组的元素不能修改 元组表示多个元素组成的序列，用于存储一串信息，数据之间用逗号隔开 元组用()定义，索引从0开始（注：不用括号，用逗号隔开也可以） \"\"\" 作者：wenlwei \"\"\" # 元组 info_1 = 5, 1, 2 info_2 = (1, 2) print(type(info_2)) print(type(info_1)) 运行结果： &lt;class 'tuple'&gt; &lt;class 'tuple'&gt; 空元组Tuple = () 元组中只有一个元素时，在元素后要添加逗号 元组常用操作 方法 功能 len() 统计元组长度 Tuple.count() 统计数据在元组中的出现次数 Tuple.index(数据) 获取数据第一次出现的索引 循环遍历\"\"\" 作者：wenlwei \"\"\" # 元组 info_1 = 5, 1, 2 info_2 = (1, 2) # print(type(info_2)) # print(type(info_1)) for i in info_2: print(i) 运行结果： 1 2 注：在实际开发中，元组的遍历不是很常用 通常元组中存储的数据不是同一类型的，在循环体中不易整体操作","categories":[],"tags":[{"name":"python","slug":"python","permalink":"https://wenlwei.github.io/tags/python/"}]},{"title":"KNN","slug":"KNN","date":"2022-02-28T08:13:10.000Z","updated":"2022-02-28T11:50:58.135Z","comments":true,"path":"posts/7c10b52f.html","link":"","permalink":"https://wenlwei.github.io/posts/7c10b52f.html","excerpt":"","text":"什么是KNNK近邻（KNN）算法是一种分类和回归算法，一个未知样本与数据集中的K个样本最相似，如果这K个样本中的大多数属于一类，则这未知样本也属于该类 简单的说就是每个样本都可以用与他最近的K个邻居来代表 KNN算法 步骤 收集数据 以所有已知类实例作为参照选择参数K 计算未知实例与所有已知实例的距离 选择最近的K个实例（一般取奇数，偶数容易会出现误差） 判断未知实例属于哪一个类 判断距离 欧式距离 马氏距离 曼哈顿距离 优缺点优点：精度高，对异常值不敏感，无数据输入假定 缺点：计算复杂度高，空间复杂度高；在样本分布不平衡时，大样本占主导地位 Python实现 电影名称 打斗镜头 接吻镜头 电影类型 Californian Man 3 104 爱情片 He’s Not Really into Dudes 2 100 爱情片 Beautiful Woman 1 81 爱情片 Kevin Longblade 101 10 动作片 RobotSlayer 3000 99 5 动作片 Amped 2 98 2 动作片 ？ 18 90 未知 注：样例来自《机器学习实战》 先将样例画出散点图很容易判断？属于爱情片 \"\"\" 作者：wenlwei \"\"\" import numpy as np import matplotlib.pyplot as plt import operator # 爱情篇的打斗镜头 x_1 = np.array([3, 2, 1]) # 爱情篇的接吻镜头 y_1 = np.array([104, 100, 81]) # 动作片的打斗镜头 x_2 = np.array([101, 99, 98]) # 动作片的接吻镜头 y_2 = np.array([10, 5, 2]) # 未知样例 x_3 = np.array([18]) y_3 = np.array([90]) # 散点图 scatter_1 = plt.scatter(x_1, y_1, c = 'g') scatter_2 = plt.scatter(x_2, y_2, c = 'r') scatter_3 = plt.scatter(x_3, y_3, c = 'k') # 画图，标签 plt.legend(handles = [scatter_1, scatter_2, scatter_3], labels = ['A', 'B', 'X'], loc = 'best') plt.show() 算法实现 \"\"\" 作者：wenlwei \"\"\" import numpy as np import matplotlib.pyplot as plt import operator # 已知数据，标签，未知数据 x_data = np.array([[3, 104], [2, 100], [1, 81], [101, 10], [99, 5], [98, 2]]) y_label = np.array(['A', 'A', 'A', 'B', 'B', 'B']) x_test = np.array([18, 90]) # 已知样本数量 x_data_size = x_data.shape[0] # 因为要计算未知样例与所有样例的距离所有需要复制x_test # 行复制x_data_size次，列复制1次 diffMat = np.tile(x_test, (x_data_size, 1)) - x_data # 插值的平方 sq_diffMat = diffMat**2 # 求和 sq_sum = sq_diffMat.sum(axis=1) # 开方 sqrt_sq_sum = sq_sum**0.5 # 按升序排序 ''' argsort函数返回的是索引 例：array = [12, 10, 45, 11, 13] 排序后为array = [1, 3, 0, 4, 2] 分别对应10，11，12，13，45 ''' sort_sqrt_sq_sum = sqrt_sq_sum.argsort() # 定义一个空字典，记录标签 classCount = {} # 设K=3 for i in range(3): # 获取标签 votelabel = y_label[sort_sqrt_sq_sum[i]] # 如果不存在就get(0) classCount[votelabel] = classCount.get(votelabel, 0) + 1 # 对classCount排序,True表示倒叙 sortedclassCount = sorted(classCount.items(), key=operator.itemgetter(1), reverse=True) # 获取最多的标签判断x_test knn = sortedclassCount[0][0] print(knn) 运行结果： A 通过结果可以知道knn=A，即？距离k个样例中爱情片最近 参考文献: 《机器学习实战》","categories":[],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://wenlwei.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}]},{"title":"kalman","slug":"kalman","date":"2022-02-20T11:50:49.000Z","updated":"2022-02-22T13:49:58.667Z","comments":true,"path":"posts/90b006b6.html","link":"","permalink":"https://wenlwei.github.io/posts/90b006b6.html","excerpt":"","text":"卡尔曼滤波 什么是卡尔曼滤波在噪声干扰下，从多个不确定信息中得出最优值。 根据前一个状态预测当前状态，即根据观测值和测量值得出最优值 状态方程（测量值）xk=xk-1+Buk+wk 观测方程yk=xk-1+vk wk,vk均满足高斯分布 wk$\\epsilon$(0,$\\sigma$Q^2^) vk$\\epsilon$(0,$\\sigma$R^2^) k表示当前时刻，B表示控制矩阵，uk表示输入，wk表示过程噪声，vk表示观测噪声 像无人驾驶汽车（匀速运动），我们如何判断汽车当前的位置 理想状态满足 xk=xk-1+v*t，实际中会因为天气，路面等产生误差，这些误差就就做过程噪声wk，vk为GPS产生的误差 此时汽车的状态为 xk=xk-1+dtv+wk，yk=yk-1+vk 我们可以根据xk和yk预测出汽车当前最接近实际的位置 方差一维方差： 理解为噪声方差和状态方差$\\sigma$t $\\sigma$t为本身的误差+wk，表示一个值 二维方差： $\\sigma$t表示一个矢量$$\\sigma_t=\\left[ \\matrix{ \\sigma_t_1\\ \\sigma_t_2 }\\right]$$每一个$\\sigma$t对应一个wk 用协方差cov表示$$cov=\\left[ \\matrix{ cov(\\sigma_t_1,\\sigma_t_1) &amp; cov(\\sigma_t_1,\\sigma_t_2)\\ cov(\\sigma_t_2,\\sigma_t_1) &amp; cov(\\sigma_t_2,\\sigma_t_2)\\ }\\right]$$三位方差： 用协方差矩阵表示$$C=\\left[ \\matrix{ cov(\\sigma_t_1,\\sigma_t_1) &amp; cov(\\sigma_t_1,\\sigma_t_2) &amp; cov(\\sigma_t_1,\\sigma_t_3) &amp; …\\ cov(\\sigma_t_2,\\sigma_t_1) &amp; cov(\\sigma_t_2,\\sigma_t_2) &amp; cov(\\sigma_t_2,\\sigma_t_3) &amp;…\\ …\\ }\\right]$$ 协方差cov=$\\Sigma$(xi-$\\mu$x)*(yj-$\\mu$y)/(n-1) 调参每一次使用卡尔曼滤波器时，主要调参过程噪声和状态噪声 x一般取0，p不可为0，为了方便收敛一般取小为1 卡尔曼公式 实现过程： 使用上一次的最优估计值预测当前值(先验估计值)，同时使用观测值修正当前值，得到最优值 最优估计值：xt 先验估计值：xt^—^ 先验估计协方差：pt^—^ 假设一个作匀加速运动的汽车模型p表示位置，v表示速度$$x_t=\\left[ \\matrix{ p\\ v\\ }\\right]$$预测模型： pi=pi-1+vi-1$\\Delta$t+a*$\\Delta$t^2^1/2 vi=vi-1+a*$\\Delta$t 即$$\\left[ \\matrix{ p_i\\ v_i\\ }\\right]=\\left[ \\matrix{ 1 &amp; \\Deltat\\ 0 &amp; 1\\ }\\right]\\left[ \\matrix{ p_i-_1\\ v_i-_1 }\\right]+\\left[ \\matrix{ \\Delta t^2/2\\ \\Delta t\\ }\\right]a_i$$xt^—^=Fxt-1^—^+But-1~ 先验估计值xt^—^=Fxt-1^—^+But-1+wk 状态转移矩阵：F 控制矩阵：B 输入：u 先验估计协方差cov(Axt,Axt)=Acov(xt,xt)A^T^ cov(Axt+a,Axt+a)=Acov(xt,xt)A^T^ cov(xt^—^,xt^—^)=cov(Fxt-1^—^+But-1+wk,Fxt-1^—^+But-1+wk) ​ =Fcov(xt-1^—^,xt-1^—^)F^T^+cov(wk,wk) ​ =Fcov(xt-1^—^,xt-1^—^)F^T^+$\\sigma$Q^2^ 即：pt^—^=Fpt-1^—^F^T^+$\\sigma$Q^2^ 测量方程测量模型： Zp=pt+vk Zv=0 即$$\\left[ \\matrix{ Z_p\\ Z_v\\ }\\right]=\\left[ \\matrix{ 1 &amp; 0\\ }\\right]\\left[ \\matrix{ p_t\\ v_t\\ }\\right]+\\left[ \\matrix{ 1 &amp; 0\\ }\\right]\\left[ \\matrix{ \\Delta p_t\\ \\Delta v_t\\ }\\right]$$Zt=Hxt+vk 注：测量量的维数不一定和状态量相同 修正估计值xt=xt^—^+Kt(Zt-Hxt^—^) 更新卡尔曼增益Kt=pt^—^H^T^/(Hpt^—^H^T^+$\\sigma$R^2^) 更新后验估计协方差pt=(1-KtH)pt^—^ 卡尔曼滤波的实现 \"\"\" 作者：wenlwei \"\"\" # 模拟机器人位置和速度 # 观测一段从0到999的值 # 速度为1的匀速行走的机器人 import numpy import matplotlib.pyplot # 矩阵 mtx = [i for i in range(1000)] mtx_w = numpy.matrix(mtx) # 高斯噪声 noise = numpy.round(numpy.random.normal(0, 1, 1000), 2) noise_mtx = numpy.matrix(noise) z_mtx = mtx_w + noise_mtx # 定义x x_mtx = numpy.matrix([[0,],[0,]]) # 定义协方差矩阵 P_mtx = numpy.matrix([[1, 0],[0, 1]]) # 定义状态转移矩阵，1秒中采一次样 f_mtx = numpy.matrix([[1, 1], [0, 1]]) # 定义状态转移协方差矩阵 q_mtx = numpy.matrix([[0.0001, 0], [0, 0.0001]]) # 定义观测矩阵 h_mtx = numpy.matrix([1, 0]) # 定义观测噪声协方差 r_mtx = numpy.matrix([1]) for i in range(1000): x_predict = f_mtx * x_mtx p_predict = f_mtx * P_mtx * f_mtx.T + q_mtx kalman = p_predict * h_mtx.T / (h_mtx * p_predict * h_mtx.T + r_mtx) x_mtx = x_predict + kalman * (z_mtx[0, i] - h_mtx * x_predict) P_mtx = (numpy.eye(2) - kalman * h_mtx) * p_predict matplotlib.pyplot.plot(x_mtx[0, 0], x_mtx[1, 0], 'ro', markersize=1) matplotlib.pyplot.show() \"\"\" 作者：wenlwei \"\"\" # 模拟机器人位置和速度 # 观测一段从0到99的值 # 速度为1的匀速行走的机器人 import numpy import matplotlib.pyplot # 矩阵,100个值显示的图像很密集不易观察所以缩小为100 mtx = [i for i in range(100)] mtx_w = numpy.matrix(mtx) # 高斯噪声 noise = numpy.round(numpy.random.normal(0, 1, 100), 2) noise_mtx = numpy.matrix(noise) z_mtx = mtx_w + noise_mtx # 定义x x_mtx = numpy.matrix([[0,],[0,]]) # 定义协方差矩阵 P_mtx = numpy.matrix([[1, 0],[0, 1]]) # 定义状态转移矩阵，1秒中采一次样 f_mtx = numpy.matrix([[1, 1], [0, 1]]) # 定义状态转移协方差矩阵 q_mtx = numpy.matrix([[0.0001, 0], [0, 0.0001]]) # 定义观测矩阵 h_mtx = numpy.matrix([1, 0]) # 定义观测噪声协方差 r_mtx = numpy.matrix([1]) for i in range(100): x_predict = f_mtx * x_mtx p_predict = f_mtx * P_mtx * f_mtx.T + q_mtx kalman = p_predict * h_mtx.T / (h_mtx * p_predict * h_mtx.T + r_mtx) x_mtx = x_predict + kalman * (z_mtx[0, i] - h_mtx * x_predict) P_mtx = (numpy.eye(2) - kalman * h_mtx) * p_predict matplotlib.pyplot.plot(x_mtx[0, 0], x_mtx[1, 0], 'ro', markersize=1) matplotlib.pyplot.show() 参考： 详解卡尔曼滤波原理 从放弃到精通！卡尔曼滤波从理论到实践~ 高中生能看懂的详细通俗讲解卡尔曼滤波Kalman Filter原理及Python实现教程 )","categories":[],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://wenlwei.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}]},{"title":"first day-python","slug":"first-day-python","date":"2022-02-06T13:29:03.000Z","updated":"2022-02-07T10:54:21.258Z","comments":true,"path":"posts/84bf5555.html","link":"","permalink":"https://wenlwei.github.io/posts/84bf5555.html","excerpt":"","text":"first pythonpycharm调式工具Step OverF8 可以单步执行代码 会把函数看成一段代码执行 Step IntoF7 可以单步执行代码 如果是函数会进入函数内部 注释# 注释 # 单行注释 # print(\"hello world\") ''' 多行注释 多行注释 多行注释 print(\"hello\") ''' print(\"hello world\") 运行结果： hello world 变量定义变量语法 name = 'dhw' 变量名 : name = : 赋值 值 : dhw ''' name = 'dhw' print(name) name = 'yzw' print(name) 运行结果： dhw yzw # 变量命名规则 ''' 1.易懂 2.第一个字符不能是数字 3.只能是字母，数字，下划线的组合 4.不能与关键字重名 # name = 'dhw' ## age1 = 12 ## age_1=12 ''' 变量类型(python3.0)数字型整型：int 浮点型：float 布尔型：bool ​ 真：True ​ 假：false 复数型：complex 非数字型字符串 列表 元组 字典 type函数可以查看变量类型 name = 'dhw' print(type(name)) age = 18 print(type(age)) print(type(2 ** 32)) 运行结果： &lt;class 'str'&gt; &lt;class 'int'&gt; &lt;class 'int'&gt; 不同变量类型的计算数字型变量之间可以直接计算True=1，false=0 num1 = 10 num2 = 1.2 T = True B = False print(num1 + num2) print(num1 + num2 + T) print(num1 + num2 + B) print(num1 * num2) print(num1 * num2 * T) print(num1 * num2 * B) 运行结果： 11.2 12.2 11.2 12.0 12.0 0.0 字符串之间使用 + 拼接字符串First_Name = '张' Last_Name = '三' print(First_Name + Last_Name) 运行结果： 张三 字符串之间和整数使用 * 重复拼接字符串First_Name = '张' Last_Name = '三' print((First_Name + Last_Name) * 3) 运行结果： 张三张三张三 注：字符串和数字型变量进行其他计算 转义字符 转义字符 描述 \\\\ 反斜杠符号 ' 单引号 \" 双引号 \\n 换行 \\t 横向制表符（垂直方向按列对齐） \\r 回车 print('1\\t2\\t3\\n10\\t20\\t30') print('1 \\'2\\' 3\\n1 \\\"2\\\" 3') print('1 2 3') # 字符1被后回车字符代替 print('1\\r2 3') 运行： 1 2 3 10 20 30 1 '2' 3 1 \"2\" 3 1 2 3 2 3 算术运算符# 算数运算符 ''' 加 : + 减 : - 乘 : * 除 : / 取整除 : // 取余 : % 幂 ： ** ''' print(1+2) print(1-2) print(1*2) print(9/2) print(9//2) print(9%2) print(9**2) 运行结果： 3 -1 2 4.5 4 1 81 输入输出 函数 功能 print(x) 打印x结果 input(x) 键盘输入(输入的任何值python都认为是字符串) type(x) 查看x变量类型 int(x) 将x转换为整数 float(x) 将x转换为浮点数 num = input('请输入：') print(num) print(type(num)) num1 = input() print(num1) print(type(num1)) 运行结果： 请输入：5646 5646 &lt;class 'str'&gt; 4564 4564 &lt;class 'str'&gt; num = '123' print(type(num)) print(type(int(num))) num1 = '123.123' print(type(num1)) print(type(float(num))) 运行结果: &lt;class 'str'&gt; &lt;class 'int'&gt; &lt;class 'str'&gt; &lt;class 'float'&gt; print函数会自动换行，在输出内容后加**end=””**不会换行 格式化输出 格式化字符 含义 %s 字符串 %d 有符号十进制整数，%06d表示输出的整数显示的位数，不足补0 %f 浮点数，%.02f表示小数点后只显示两位 %% 输出% # 定义一个字符串变量name，输出：我的名字叫小明，请多多关照 name = '小明' print('我的名字叫 %s, 请多多关照' % name) # 输出我的学号是00000x stu_id = int(input()) print('我的学号是 %06d' % stu_id) # 定义变量price,num,money,输出苹果单价price，购买了num，需支付，money, price = float(input()) num = int(input()) money = float(price * num) print('苹果单价 %.02f, 购买了 %d, 需支付 %.02f' % (price,num,money)) # 定义一个小数scale，输出数据比例是x scale = float(input()) print('数据比例是 %.02f%%' % scale) 运行结果: 我的名字叫 小明, 请多多关照 4 我的学号是 000004 10.00 5 苹果单价 10.00, 购买了 5, 需支付 50.00 50.32 数据比例是 50.32% 判断语句age = int(input()) if age &gt;= 18: print('可以进网吧') else: print('不能进网吧') 运行结果: 17 不能进网吧 age = int(input()) if age &gt;= 18: print('可以进网吧') else: print('不能进网吧') 运行结果: 20 可以进网吧 比较运算符 运算符 描述 == 判断两个操作数的值是否相等 != 判断两个操作数的值是否不想等 &gt; 判断左操作数的值是否大于右操作数 &lt; 判断左操作数的值是否小于右操作数 &gt;= 判断左操作数的值是否大于等于右操作数 &lt;= 判断左操作数的值是否小于等于右操作数 逻辑运算python逻辑运算符and/与 条件1 条件2 结果 True True True True False False … … or/或 条件1 条件2 结果 True True True True False True False False False not/非 条件 结果 True False False True age = int(input()) if age &gt;=0 and age &lt;=100 : print('满足要求') else : print('不满足') p_score = float(input()) c_score = float(input()) if p_score &gt;= 60 or c_score &gt;= 60 : print('成绩及格') else : print('成绩不合格，请努力') 运行结果: 65 满足要求 54 32 成绩不合格，请努力 is_employee = False if not is_employee : print('暗码错误，3s后自毁!!!') else : print('暗码正确，允许进入') 运行结果： True 暗码错误，3s后自毁!!! elifelifh和else都必须与if同时使用 h_name = input() if h_name == '情人节' : print('玫瑰 and 电影') elif h_name == '平安夜' : print('苹果 and 吃大餐') elif h_name == '生日' : print('蛋糕') else : print('有你的每一天都是节日') 运行结果： 生日 蛋糕 随机数工具包random random.randint(a,b),返回**[a,b]**之间的整数 应用——石头剪刀布import random print('请出拳(石头，剪刀，布)：') player = input() print('玩家选择：%s' % player) computer = random.randint(1 , 3) if computer == 1 : Computer = '石头' print('AI选择：%s' % Computer) if player == '布' : print('玩家胜利，撒花') elif player == '石头' : print('平局，真的没有偷看吗') else : print('可惜，差一点就赢了') elif computer == 2 : Computer = '剪刀' print('AI选择：%s' % Computer) if player == '石头' : print('玩家胜利，撒花') elif player == '剪刀' : print('平局，真的没有偷看吗') else : print('可惜，差一点就赢了') else : Computer = '布' print('AI选择：%s' % Computer) if player == '剪刀' : print('玩家胜利，撒花') elif player == '布' : print('平局，真的没有偷看吗') else : print('可惜，差一点就赢了') 运行: 请出拳(石头，剪刀，布)： 剪刀 玩家选择：剪刀 AI选择：布 玩家胜利，撒花","categories":[],"tags":[{"name":"python","slug":"python","permalink":"https://wenlwei.github.io/tags/python/"}]},{"title":"second day_python","slug":"second-day-python","date":"2022-02-06T09:27:49.000Z","updated":"2022-03-01T03:57:56.421Z","comments":true,"path":"posts/8d8e15c3.html","link":"","permalink":"https://wenlwei.github.io/posts/8d8e15c3.html","excerpt":"","text":"second day_python循环while循环while 条件(判断 计数器 是否达到 目标次数): ​ 条件满足时，做到事1 ​ 条件满足时，做的事2 ​ … ​ 处理条件(计算球+1) i = 0 while i &lt; 5 : print('hello world') i+=1 print('i = %d' % i) 运行: hello world hello world hello world hello world hello world i = 5 0~100求和i = 0 sum = 0 while i &lt;= 100 : sum += i i+=1 print('sum = %d' % sum) 运行: 5050 0~100偶数求和i = 0 sum = 0 while i &lt;= 100 : if i % 2 == 0 : sum += i i+=1 print('sum = %d' % sum) 运行: 2550 for循环for i in range(循环次数): ​ … ​ … break和continuebreak满足某条件时，退出循环 continue满足某条件时，退出当前循环，开始下一次循环 i = 0 sum = 0 while i &lt;= 5 : sum += i if sum &gt;= 3 : break i+=1 j = 0 ans = 0 while j&lt;=5 : ans += j if ans == 3: continue j+=1 print('sum = %d,i = %d' % (sum,i)) print('ans = %d,j = %d' % (ans,j)) 运行： sum = 3,i = 2 ans = 17,j = 6 循环嵌套打印小星星i = 1 s_tr = '*' while i &lt;= 5 : print(s_tr*i) i+=1 运行： * ** *** **** ***** i = 0 j = 0 while i &lt; 5 : j = 0 while j &lt;= i : print('*',end='') j += 1 print('') i += 1 运行： * ** *** **** ***** 打印九九乘法表i = 1 while i &lt;= 9 : j = 1 while j &lt;= i : # 打印每行 print('%d * %d = %d\\t' % (j,i,i * j),end=' ') j += 1 i += 1 print('') 运行： 1 * 1 = 1 1 * 2 = 2 2 * 2 = 4 1 * 3 = 3 2 * 3 = 6 3 * 3 = 9 1 * 4 = 4 2 * 4 = 8 3 * 4 = 12 4 * 4 = 16 1 * 5 = 5 2 * 5 = 10 3 * 5 = 15 4 * 5 = 20 5 * 5 = 25 1 * 6 = 6 2 * 6 = 12 3 * 6 = 18 4 * 6 = 24 5 * 6 = 30 6 * 6 = 36 1 * 7 = 7 2 * 7 = 14 3 * 7 = 21 4 * 7 = 28 5 * 7 = 35 6 * 7 = 42 7 * 7 = 49 1 * 8 = 8 2 * 8 = 16 3 * 8 = 24 4 * 8 = 32 5 * 8 = 40 6 * 8 = 48 7 * 8 = 56 8 * 8 = 64 1 * 9 = 9 2 * 9 = 18 3 * 9 = 27 4 * 9 = 36 5 * 9 = 45 6 * 9 = 54 7 * 9 = 63 8 * 9 = 72 9 * 9 = 81 函数定义函数——**封装** 独立的功能 调用函数——享受**封装** 的成功 函数使得效率提高及代码的**重用** 定义函数关键字**def** 函数名命名规则： ​ 字母，数字，下划线随意组合 ​ 不能以数字开头 ​ 不能以关键字命名 # 只是封装不会主动执行 def 函数名(): 封装代码 调用函数创建一个新的python文件导入工具包 关键字**import** 使用函数 文件名.函数名 import 文件名 文件名.函数名 或者在原文件上执行def 函数名(): 封装代码 # 调用函数 函数名() 示例九九乘法表def mul_tab(): i = 1 while i &lt;= 9: j = 1 while j &lt;= i: # 打印每行 print('%d * %d = %d\\t' % (j, i, i * j), end=' ') j += 1 i += 1 print('') import mul_tab mul_tab.mul_tab() 运行： 1 * 1 = 1 1 * 2 = 2 2 * 2 = 4 1 * 3 = 3 2 * 3 = 6 3 * 3 = 9 1 * 4 = 4 2 * 4 = 8 3 * 4 = 12 4 * 4 = 16 1 * 5 = 5 2 * 5 = 10 3 * 5 = 15 4 * 5 = 20 5 * 5 = 25 1 * 6 = 6 2 * 6 = 12 3 * 6 = 18 4 * 6 = 24 5 * 6 = 30 6 * 6 = 36 1 * 7 = 7 2 * 7 = 14 3 * 7 = 21 4 * 7 = 28 5 * 7 = 35 6 * 7 = 42 7 * 7 = 49 1 * 8 = 8 2 * 8 = 16 3 * 8 = 24 4 * 8 = 32 5 * 8 = 40 6 * 8 = 48 7 * 8 = 56 8 * 8 = 64 1 * 9 = 9 2 * 9 = 18 3 * 9 = 27 4 * 9 = 36 5 * 9 = 45 6 * 9 = 54 7 * 9 = 63 8 * 9 = 72 9 * 9 = 81 函数文档注释1.在开发中使用三对引号写在定义函数下方 2.在函数调用位置使用快捷键CTRL+Q可以查看函数的说明信息 3.注释与函数保持一定距离(习惯) def ...(): '''注释''' 封装代码 函数的参数有参函数与无参函数def sum_2_num(num1, num2): '''两数求和''' result = num1 + num2 print('%d + %d = %d' % (num1, num2, result)) sum_2_num(10, 45) 运行： 10 + 45 = 55 有参函数：灵活可以处理不同的值 无参函数：只能处理固定的值 形参和实参形参：定义函数时小括号中的参数，用来接收参数 实参：调用函数时小括号中的参数，用来传递数据到函数内部 返回值return函数执行完成之后给调用者返回一个结果 return之后的语句都不会执行 函数的嵌套调用在函数中调用另一个函数 def sum_2_num(num1, num2): '''两数求和''' result = num1 + num2 return result def mul_10(): '''嵌套调用sum_2_num()''' result = sum_2_num(10, 20) * 10 return result print(mul_10()) 运行结果： 300 def print_line(char, times): print(char * times) def print_times(char, times, ans): i = 0 while i &lt; ans : print_line(char, times) i += 1 ch = input('请输入要打印的字符 :') times = int(input('请输入要打印的次数 :')) ans = int(input('请输入要打印的行数 :')) print_times(ch, times, ans) 运行结果： 请输入要打印的字符 :* 请输入要打印的次数 :10 请输入要打印的行数 :3 ********** ********** ********** 模块","categories":[],"tags":[{"name":"python","slug":"python","permalink":"https://wenlwei.github.io/tags/python/"}]},{"title":"计算机网络","slug":"计算机网络","date":"2021-12-25T05:29:23.000Z","updated":"2022-01-30T11:16:18.024Z","comments":true,"path":"posts/e255a10a.html","link":"","permalink":"https://wenlwei.github.io/posts/e255a10a.html","excerpt":"","text":"网络计算机网络由若干节点（node）和连接这些节点的链路（link）组成 互联网全世界最大的，覆盖全球的计算机网络 互连网通过路由器把网络连接起来构成范围更大的网络 网络：将许多计算机连接在一起 互联网标准所有互联网标准都已RFC的形式在护粮网是发表 互联网草案六个月有效期，这个阶段还不是RFC为文档 建议标准开始成为RFC文档 互联网标准达到正式标准后，每个标准被分配一个编号 STD***。一个标准可以和多个RFC文档关联 RFC之间的关系 互联网组成边缘部分边缘部分：由所有连接在互联网上的主机构成。用户直接使用 这些主机又被称为端系统 端系统之间的两种通信方式客户—服务器(c/s) 客户是请求方，服务器是提供方 对等方式(p2p) 本质仍是C/S方式，只是每一个主机即既是服务器又是客户 核心部分由许多网络和把他们连接起来的路由器组成 路由器输入和输出端口无直接连接 工作过程：把收到的分组暂时放入缓存；查找转发表；寻找合适的端口转发 注：主机是为用户进行信息处理，路由器是对分组进行存储转发 电路交换通过交换机将主机连接起来 特点： 1.建立连接，释放连接，即面向连接 2.独占链路资源 3.专用的通路 4.传输效率低 存储转发存储转发分为报文交换和报文分组 报文交换：不管发送数据长度多少，都当作一个逻辑单元发送 分组交换：限制一次传输的最大长度，超出最大长度就分为多个报文分组发送 分组交换原理与优点： 存储转发优点1.线路利用率高，提高系统效率 2.动态选择通过的最佳路径 3.可以对不同通信速率的线路进行速率转换，也可以对不同的数据代码格式进行变换 4.可以平滑通信量 计算机网络性能速率速率是最重要的性能指标，指数据的传送速率，也称数据率或比特率 单位：bit/s或kbit/s、Mbit/s、Gbit/s等 k=10^3,M=10^6,G=10^9 比特 1字节(B)=8 bit 15GB=15 * 2^30 * 8 bit k=2^10,M=2^20,G=2^30,T=2^40 带宽本指信号具有的频带宽度，最高频率和最低频率的差（Hz），在计算机网络中表示某通道传送数据的能力，在单位时间内网络中的某信道所能通过的最高数据率，单位bit/s 吞吐量单位时间通过某个网络的数据量 受网络带宽或网络额定速率的限制 时延指数据从网络一端到另一端的时间 也称延迟或迟延 总时延=发送时延+传播时延+处理时延+排队时延 发送时延发送时延=数据帧长度(bit)/发送速率(bit/s) 传播时延传播时延=信道长度(m)/传播速率(m/s) 处理时延主机或路由器收到分组后，为处理数据所花费的时间 排队时延在路由器中等待的时间 排队时延长短通常取决于网络中当时的通信量 通信量非常大时，相当于排队时延无穷 注：对于高速网络链路，提高的是发送速率不是传播速率 时延带宽积时延带宽积=传播时延*带宽 往返时间RTT从发送数据开始到接收方确认的总时间 利用率分为信道利用率和网络利用率 丢包率丢包率=丢包数/已发分组总数 计算机网络类别按范围分： 按使用者分： 公用网，专用网 计算机网络体系结构对等实体：通信双方同时处于活动的元素 计算机网络体系结构是计算机网络的各层及其协议的集合 TCP/IP参考模型 OSI参考模型 五种协议的网络参考模型 功能 TCP/IP与OSI比较 物理层物理层作用：尽可能屏蔽掉不同传输媒体和通信手段差异，确定与传输媒体的接口特性 物理层主要任务： 模拟信号：连续的信号 数字信号：离散的信号 基带信号：即基本频带信号，来自信源的信号 信号为什么要调制：基带信号包含较多的低频成分，甚至有直流成分，许多信号不能传输 调制方式：基带调制，带通调制 编码方式：不归零制，归零制，曼切斯特，差分曼切斯特 数据：运送消息的实体 信号：数据电气的或电磁的表现 模拟信号：代表消息的参数的取值是连续的 数学信号：代表消息的参数的取值是离散的 码元：代表不同离散值的基本波形 注：二进制编码时，只有两种不同的码元，0，1 信道单向信道：只能有一个方向的通信没有反方向 双向交替通信：双方都可以发送信息，但不能同时发送 双向同时通信：双方可以同时发送和接收 基带调制：仅变换基带信号的波形，变换后仍是基带信号 带通调制：使用载波进行调制，并转换为模拟信号 基本的带通调制方法二元制调制：调幅（AM）：载波的振幅 调频（FM）：载波的频率 调相（PM）：载波的初始相位 奈氏准则：码元传输的最高速率为20000（码元/秒） 信噪比：信号的平均功率和噪声的平均功率之比，S/N，分贝（dB）作为度量单位 dB=10lg(S/N) （dB） 香农公式信道的极限信息传输速率C=Wlog2(1+S/N) (bit/s) W为信道带宽 注： 奈氏准则：理想条件下，码元极限传输速率 香农定理：噪声，干扰条件下，信息极限传输速率 导引型传输媒体双绞线 剥线——理线——插线——压线 同轴电缆具有很好的抗干扰特性，被广泛用于传输较高的速率 光缆多模光纤：可以存在多条不同角度入射的光线，适用近距离传输 单模光纤：不会产生多次反射 光纤通信常用三个波段中心：850nm，1300nm，1550nm 非导引型传输媒体短波通信：主要靠电离层的反射，质量差，速率低 微波：主要是直线传播 信道复用技术 频分服用 FDM同样的时间占用不同的带宽资源 各子信道之间设立隔离带，各路信号互不干扰 总频率宽度大于各个子信道频率之和 特点：以并行的方式工作 充分利用带宽，效率较高 若每一个用户占用的带宽不变，当复用的用户数据增加时，信道总宽度也变宽 更多的用户轮流适用这n个频带，称为频分多址接入FDMA，简称频分多址 时分复用TDM 统计时分复用STDM 波分复用WDM 码分复用CDM 数据链路层点对点信道：一对一的点对点通信方式 广播信道：一对多广播通信 数据链路和桢","categories":[],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://wenlwei.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"日撸Java2","slug":"日撸Java2","date":"2021-12-20T15:28:48.000Z","updated":"2022-01-29T10:46:53.396Z","comments":true,"path":"posts/97a699da.html","link":"","permalink":"https://wenlwei.github.io/posts/97a699da.html","excerpt":"","text":"线性数据结构第三天顺序表1 创建一个空表 2 给空表赋值 3 将表中的值赋给字符串 4 清空表中元素 5 查找给定元素所处的位置. 找不到就返回 -1.6 在给定位置增加元素. 如果顺序表已满, 或位置不在已有位置范围之内, 就拒绝增加.7 删除指定位置的元素. 要处理给定位置不合法的情况. 该位置必须是已经有数据的. /** * Sequential list. * * @author Lenovo. */ public class SequentialList { /** * The maximal length of the list. It is a constant. */ public static final int MAX_LENGTH = 10; /** * The actual length not exceeding MAX_LENGTH. Attention: length is not only * the member variable of Sequential list, but also the member variable of * Array. In fact, a name can be the member variable of different classes. */ int length; /** * The data stored in an array. */ int[] data; /** ********************* * Construct an empty sequential list. ********************* */ public SequentialList() { length = 0; data = new int[MAX_LENGTH]; }// Of the first constructor /** ********************* * Construct a sequential list using an array. * * @param paraArray * The given array. Its length should not exceed MAX_LENGTH. For * simplicity now we do not check it. ********************* */ public SequentialList(int[] paraArray) { data = new int[MAX_LENGTH]; length = paraArray.length; // Copy data. for (int i = 0; i &lt; paraArray.length; i++) { data[i] = paraArray[i]; } // Of for i }// Of the second constructor /** ********************* * Overrides the method claimed in Object, the superclass of any class. ********************* */ public String toString() { String resultString = \"\"; if (length == 0) { return \"empty\"; } // Of if for (int i = 0; i &lt; length - 1; i++) { resultString += data[i] + \", \"; } // Of for i resultString += data[length - 1]; return resultString; }// Of toString /** ********************* * Reset to empty. ********************* */ public void reset() { length = 0; }// Of reset /** ********************* * The entrance of the program. * * @param args * Not used now. ********************* */ /** ********************* * Find the index of the given value. If it appears in multiple positions, * simply return the first one. * * @param paraValue The given value. * @return The position. -1 for not found. ********************* */ public int indexOf(int paraValue) { int tempPosition = -1; for (int i = 0; i &lt; length; i++) { if (data[i] == paraValue) { tempPosition = i; break; } // Of if } // Of for i return tempPosition; }// Of indexOf /** ********************* * Insert a value to a position. If the list is already full, do nothing. * * @param paraPosition The given position. * @param paraValue The given value. * @return Success or not. ********************* */ public boolean insert(int paraPosition, int paraValue) { if (length == MAX_LENGTH) { System.out.println(\"List full.\"); return false; } // Of if if ((paraPosition &lt; 0) || (paraPosition &gt; length)) { System.out.println(\"The position \" + paraPosition + \" is out of bounds.\"); return false; } // Of if // From tail to head. The last one is moved to a new position. Because length &lt; MAX_LENGTH, no exceeding occurs. for (int i = length; i &gt; paraPosition; i--) { data[i] = data[i - 1]; } // Of for i data[paraPosition] = paraValue; length++; return true; }// Of insert /** ********************* * Delete a value at a position. * * @param paraPosition The given position. * @return Success or not. ********************* */ public boolean delete(int paraPosition) { if ((paraPosition &lt; 0) || (paraPosition &gt;= length)) { System.out.println(\"The position \" + paraPosition + \" is out of bounds.\"); return false; } // Of if // From head to tail. for (int i = paraPosition; i &lt; length - 1; i++) { data[i] = data[i + 1]; } // Of for i length--; return true; }// Of delete /** ********************* * The entrance of the program. * * @param args Not used now. ********************* */ public static void main(String args[]) { int[] tempArray = { 1, 4, 6, 9 }; SequentialList tempFirstList = new SequentialList(tempArray); System.out.println(\"After initialization, the list is: \" + tempFirstList.toString()); System.out.println(\"Again, the list is: \" + tempFirstList); int tempValue = 4; int tempPosition = tempFirstList.indexOf(tempValue); System.out.println(\"The position of \" + tempValue + \" is \" + tempPosition); tempValue = 5; tempPosition = tempFirstList.indexOf(tempValue); System.out.println(\"The position of \" + tempValue + \" is \" + tempPosition); tempPosition = 2; tempValue = 5; tempFirstList.insert(tempPosition, tempValue); System.out.println( \"After inserting \" + tempValue + \" to position \" + tempPosition + \", the list is: \" + tempFirstList); tempPosition = 8; tempValue = 10; tempFirstList.insert(tempPosition, tempValue); System.out.println( \"After inserting \" + tempValue + \" to position \" + tempPosition + \", the list is: \" + tempFirstList); tempPosition = 3; tempFirstList.delete(tempPosition); System.out.println(\"After deleting data at position \" + tempPosition + \", the list is: \" + tempFirstList); for (int i = 0; i &lt; 8; i++) { tempFirstList.insert(i, i); System.out.println(\"After inserting \" + i + \" to position \" + i + \", the list is: \" + tempFirstList); } // Of for i tempFirstList.reset(); System.out.println(\"After reset, the list is: \" + tempFirstList); }// Of main }// Of class SequentialList","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://wenlwei.github.io/tags/java/"}]},{"title":"日撸Java 1","slug":"日撸Java1","date":"2021-12-17T14:30:58.000Z","updated":"2022-01-29T10:46:53.396Z","comments":true,"path":"posts/9db90237.html","link":"","permalink":"https://wenlwei.github.io/posts/9db90237.html","excerpt":"","text":"Java第一天Hello Worldpackage base; /** * This is the first code. * @author Lenovo * */ public class HelloWorld { public static void main(String args[]) { System.out.println(\"Hello, world\"); }//of main }//of class HelloWorld 基本算术操作加、减、乘、除、整除、取余. 熟悉 println 的中阶用法. package base; /** * This is the second code. * @author Lenovo * */ public class BasicOperations { public static void main(String args[]) { int tempFirstInt,tempSecondInt,tempResultInt; double tempFirstDouble,tempSecondDouble,tempResultDouble; tempFirstInt=15; tempSecondInt=4; tempFirstDouble=1.2; tempSecondDouble=3.5; //Addition tempResultInt=tempFirstInt+tempSecondInt; tempResultDouble=tempFirstDouble+tempSecondDouble; System.out.println(\"\"+tempFirstInt+\" + \"+tempSecondInt+\" + \"+tempResultInt); System.out.println(\"\"+tempFirstInt+\" + \"+tempSecondDouble+\" + \"+tempResultDouble); //Subtraction tempResultInt = tempFirstInt - tempSecondInt; tempResultDouble = tempFirstDouble - tempSecondDouble; System.out.println(\"\" + tempFirstInt + \" - \" + tempSecondInt + \" = \" + tempResultInt); System.out.println(\"\" + tempFirstDouble + \" - \" + tempSecondDouble + \" = \" + tempResultDouble); //Multiplication tempResultInt = tempFirstInt * tempSecondInt; tempResultDouble = tempFirstDouble * tempSecondDouble; System.out.println(\"\" + tempFirstInt + \" * \" + tempSecondInt + \" = \" + tempResultInt); System.out.println(\"\" + tempFirstDouble + \" * \" + tempSecondDouble + \" = \" + tempResultDouble); //Division tempResultInt = tempFirstInt / tempSecondInt; tempResultDouble = tempFirstDouble / tempSecondDouble; System.out.println(\"\" + tempFirstInt + \" / \" + tempSecondInt + \" = \" + tempResultInt); System.out.println(\"\" + tempFirstDouble + \" / \" + tempSecondDouble + \" = \" + tempResultDouble); //Modulus tempResultInt = tempFirstInt % tempSecondInt; System.out.println(\"\" + tempFirstInt + \" % \" + tempSecondInt + \" = \" + tempResultInt); } } 基本if语句if then else. 方法调用: 增加代码的复用性. 方法头部规范的注释, 是后期生成文档的基础. package base; /** * The usage of the if statement * @author Lenovo * */ public class IfStatement { /** ********************* * The entrance of the program. * * @param args Not used now. ********************* */ public static void main(String args[]) { int tempNumber1,tempNumber2; //Try a positive value tempNumber1=5; if(tempNumber1&gt;=0) { tempNumber2=tempNumber1; }else { tempNumber2=-tempNumber1; }//of if System.out.println(\"The absolute value of \" + tempNumber1 + \" is \" + tempNumber2); // Try a negative value // Lines 27 through 33 are the same as Lines 15 through 19 tempNumber1 = -3; if (tempNumber1 &gt;= 0) { tempNumber2 = tempNumber1; } else { tempNumber2 = -tempNumber1; } // Of if System.out.println(\"The absolute value of \" + tempNumber1 + \" is \" + tempNumber2); // Now we use a method/function for this purpose. tempNumber1 = 6; System.out.println(\"The absolute value of \" + tempNumber1 + \" is \" + abs(tempNumber1)); tempNumber1 = -8; System.out.println(\"The absolute value of \" + tempNumber1 + \" is \" + abs(tempNumber1)); }// Of main /** ********************* * The absolute value of the given parameter. * * @param paraValue The given value. ********************* */ public static int abs(int paraValue) { if (paraValue &gt;= 0) { return paraValue; } else { return -paraValue; } // Of if }// Of abs }// Of class IfStatement // Math function library Math.abs() function 闰年判断能被4整除不能被100整除或者能被400整除 package base; /** * The complex usage of the if statement. * * @author Lenovo */ public class LeapYear { /** ********************* * The entrance of the program. * * @param args Not used now. ********************* */ public static void main(String args[]) { // Test isLeapYear int tempYear = 2021; System.out.print(\"\" + tempYear + \" is \"); if (!isLeapYear(tempYear)) { System.out.print(\"NOT \"); } // Of if System.out.println(\"a leap year.\"); tempYear = 2000; System.out.print(\"\" + tempYear + \" is \"); if (!isLeapYear(tempYear)) { System.out.print(\"NOT \"); } // Of if System.out.println(\"a leap year.\"); tempYear = 2100; System.out.print(\"\" + tempYear + \" is \"); if (!isLeapYear(tempYear)) { System.out.print(\"NOT \"); } // Of if System.out.println(\"a leap year.\"); tempYear = 2004; System.out.print(\"\" + tempYear + \" is \"); if (!isLeapYear(tempYear)) { System.out.print(\"NOT \"); } // Of if System.out.println(\"a leap year.\"); // Test isLeapYearV2 System.out.println(\"Now use the second version.\"); tempYear = 2021; System.out.print(\"\" + tempYear + \" is \"); if (!isLeapYearV2(tempYear)) { System.out.print(\"NOT \"); } // Of if System.out.println(\"a leap year.\"); tempYear = 2000; System.out.print(\"\" + tempYear + \" is \"); if (!isLeapYearV2(tempYear)) { System.out.print(\"NOT \"); } // Of if System.out.println(\"a leap year.\"); tempYear = 2100; System.out.print(\"\" + tempYear + \" is \"); if (!isLeapYearV2(tempYear)) { System.out.print(\"NOT \"); } // Of if System.out.println(\"a leap year.\"); tempYear = 2004; System.out.print(\"\" + tempYear + \" is \"); if (!isLeapYearV2(tempYear)) { System.out.print(\"NOT \"); } // Of if System.out.println(\"a leap year.\"); }// Of main /** ********************* * Is the given year leap * * @param Lenovo ********************* */ public static boolean isLeapYear(int paraYear) { if ((paraYear % 4 == 0) &amp;&amp; (paraYear % 100 != 0) || (paraYear % 400 == 0)) { return true; } else { return false; } // Of if }// Of isLeapYear /** ********************* * * @param Lenovo ********************* */ public static boolean isLeapYearV2(int paraYear) { if (paraYear % 4 != 0) { return false; } else if (paraYear % 400 == 0) { return true; } else if (paraYear % 100 == 0) { return false; } else { return true; } // Of if }// Of isLeapYearV2 }// Of class LeapYea Java第二天矩阵元素相加import java.util.Arrays; /** * This is second day. * * @author Lenovo. */ public class MatrixAddition{ /** * * @param args not used now. */ public static void main(String args[]) { matrixElementSumTest(); matrixAdditionTest(); }//of main /** ********************* * Sum the element of a matrix. * * @param parMatrix The given matrix. * @return The sum of all its elements. ********************* */ public static int matrixElementSum(int[][] paraMatrix) { int resultSum = 0; for (int i = 0; i &lt; paraMatrix.length; i++) { for(int j = 0; j &lt; paraMatrix[0].length; j++) { resultSum += paraMatrix[i][j]; } // of for j } // of for i return resultSum; } /** ********************* *Unit test for respective method. ********************* */ public static void matrixElementSumTest() { int[][] tempMatrix = new int[3][4]; for (int i = 0; i &lt; tempMatrix.length; i++) { for (int j = 0; j&lt; tempMatrix[0].length; j++) { tempMatrix[i][j] = i * 10 + j; } // of for j } // of for i System.out.println(\"The matrix is: \\r\\n\" + Arrays.deepToString(tempMatrix)); System.out.println(\"The matrix element sum is: \" + matrixElementSum(tempMatrix) + \"\\r\\n\"); }// of matrixElementSumTest /** ********************* * Add two matrices. Attention: NO error check is provided at this moment. * * @param paraMatrix1 The first matrix. * @param paraMatrix2 The second matrix. It should have the same size as * the first one's. * @return The addition of these matrices. ********************* */ public static int[][] matrixAddition(int[][] paraMatrix1, int[][] paraMatrix2) { int[][] resultMatrix = new int[paraMatrix1.length][paraMatrix1[0].length]; for (int i = 0; i &lt; paraMatrix1.length; i++) { for (int j = 0; j &lt; paraMatrix1[0].length; j++) { resultMatrix[i][j] = paraMatrix1[i][j] + paraMatrix2[i][j]; } // Of for j } // Of for i return resultMatrix; }// Of matrixAddition /** ********************* * Unit test for respective method. ********************* */ public static void matrixAdditionTest() { int[][] tempMatrix = new int[3][4]; for (int i = 0; i &lt; tempMatrix.length; i++) { for (int j = 0; j &lt; tempMatrix[0].length; j++) { tempMatrix[i][j] = i * 10 + j; } // Of for j } // Of for i System.out.println(\"The matrix is: \\r\\n\" + Arrays.deepToString(tempMatrix)); int[][] tempNewMatrix = matrixAddition(tempMatrix, tempMatrix); System.out.println(\"The new matrix is: \\r\\n\" + Arrays.deepToString(tempNewMatrix)); }// Of matrixAdditionTest }// Of class MatrixAddition 矩阵元素相乘import java.util.Arrays; /** * This is the eighth code. Names and comments should follow my style strictly. * * @author Lenovo. */ public class MatrixMultiplication { /** ********************* * The entrance of the program. * * @param args Not used now. ********************* */ public static void main(String args[]) { matrixMultiplicationTest(); }// Of main /** ********************* * Matrix multiplication. The columns of the first matrix should be equal to the * rows of the second one. * * @param paraFirstMatrix The first matrix. * @param paraSecondMatrix The second matrix. * @return The result matrix. ********************* */ public static int[][] multiplication(int[][] paraFirstMatrix, int[][] paraSecondMatrix) { int m = paraFirstMatrix.length; int n = paraFirstMatrix[0].length; int p = paraSecondMatrix[0].length; // Step 1. Dimension check. if (paraSecondMatrix.length != n) { System.out.println(\"The two matrices cannot be multiplied.\"); return null; } // Of if // Step 2. The loop. int[][] resultMatrix = new int[m][p]; for (int i = 0; i &lt; m; i++) { for (int j = 0; j &lt; p; j++) { for (int k = 0; k &lt; n; k++) { resultMatrix[i][j] += paraFirstMatrix[i][k] * paraSecondMatrix[k][j]; } // Of for k } // Of for j } // Of for i return resultMatrix; }// Of multiplication /** ********************* * Unit test for respective method. ********************* */ public static void matrixMultiplicationTest() { int[][] tempFirstMatrix = new int[2][3]; for (int i = 0; i &lt; tempFirstMatrix.length; i++) { for (int j = 0; j &lt; tempFirstMatrix[0].length; j++) { tempFirstMatrix[i][j] = i + j; } // Of for j } // Of for i System.out.println(\"The first matrix is: \\r\\n\" + Arrays.deepToString(tempFirstMatrix)); int[][] tempSecondMatrix = new int[3][2]; for (int i = 0; i &lt; tempSecondMatrix.length; i++) { for (int j = 0; j &lt; tempSecondMatrix[0].length; j++) { tempSecondMatrix[i][j] = i * 10 + j; } // Of for j } // Of for i System.out.println(\"The second matrix is: \\r\\n\" + Arrays.deepToString(tempSecondMatrix)); int[][] tempThirdMatrix = multiplication(tempFirstMatrix, tempSecondMatrix); System.out.println(\"The third matrix is: \\r\\n\" + Arrays.deepToString(tempThirdMatrix)); System.out.println(\"Trying to multiply the first matrix with itself.\\r\\n\"); tempThirdMatrix = multiplication(tempFirstMatrix, tempFirstMatrix); System.out.println(\"The result matrix is: \\r\\n\" + Arrays.deepToString(tempThirdMatrix)); }// Of matrixMultiplicationTest }// Of class MatrixMultiplication Task1import java.util.Arrays; import java.util.Random; public class Task1{ public static void main(String args[]) { task1(); } /** ******************** *method. ******************** */ public static void task1() { int[][] Stuscore = new int [5][3]; int Lowestscore = 50; int Highestscore = 100; Random Ran = new Random(); for (int i = 0; i &lt; 5; i++) { for (int j = 0; j&lt; 3; j++) { Stuscore[i][j] = Lowestscore + Ran.nextInt(Highestscore - Lowestscore); } } // of for student score System.out.println(\"Students score:\\n\" + Arrays.deepToString(Stuscore)); int[] Totalscore = new int[5]; for (int i = 0; i &lt; 5; i++) { for (int j =0; j &lt; 3; j++) { if (Stuscore[i][j] &lt; 60) { Totalscore[i] = 0; break; } Totalscore[i] += Stuscore[i][j]; } } // of for Totalscore System.out.println(\"Students totalscore:\\n\"+ Arrays.toString(Totalscore)); int Bestgrade = -1; int Worstgrade = 305; int Bestindex = -1; int Worstindex = -1; for (int i = 0; i &lt; 5; i++) { if (Totalscore[i] == 0) continue; if(Bestgrade &lt; Totalscore[i]) { Bestgrade = Totalscore[i]; Bestindex = i; } if (Worstgrade &gt; Totalscore[i]) { Worstgrade = Totalscore[i]; Worstindex = i; } } // of for best and worst. if (Bestindex == -1) { System.out.println(\"Cannot find bestgrade.\"); }else { System.out.println(\"The best student is No.\" + Bestindex + \"with score is \"+ Totalscore[Bestindex]); } if (Worstindex == -1) { System.out.println(\"Cannot find worstgrade.\"); }else { System.out.println(\"The worst student is No.\" + Worstindex + \"with score is \" + Totalscore[Worstindex]); } } // of void task1. } // of class Task1. 运行结果： Students score: [[77, 92, 96], [97, 87, 76], [82, 68, 74], [51, 88, 79], [54, 97, 88]] Students totalscore: [265, 260, 224, 0, 0] The best student is No.0with score is 265 The worst student is No.2with score is 224","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://wenlwei.github.io/tags/Java/"}]},{"title":"机器学习","slug":"机器学习","date":"2021-12-16T14:51:18.000Z","updated":"2022-01-30T11:15:58.043Z","comments":true,"path":"posts/498ab7d9.html","link":"","permalink":"https://wenlwei.github.io/posts/498ab7d9.html","excerpt":"","text":"机器学习机器学习基础什么是机器学习？ 通过对信息的统计来利用信息建立模型然后使用模型预测的方法。即将大量的数据转换成有用的信息。 为什么要进行机器学习？ 机器学习的主要任务：回归，分类 分类：将实例数据进行合适分类 回归：主要用于预测数值型数据 训练集：拥有已大量分类的数据，是用于训练机器学习算法的数据样本集合 目标变量：是机器学习算法的预测结果，分类算法中目标变量通常是标称型，回归算法中通常是连续型 注意：特征或属性通常是训练样本集的列，是独立测量得到的结果，多个特征联系在一起共同组成一个训练样本 训练数据：机器学习开始时作为算法输入的训练样本集 测试数据：训练完成后输入的训练样本集 注：测试样本时不提供目标变量，由程序决定 分类和回归都称为监督学习，这类算法必须知道要预测什么，即目标变量的分类信息 无监督学习即数据没有类别信息，也不给定目标值 聚类：无监督学习中，将数据集合分成类似的对象组成的多个类的过程 密度估计：寻找描述数据统计值的过程 无监督学习可以减少数据特征的维度 监督学习的用途 无监督学习的用途 k-近邻算法 K-均值 朴素贝叶斯算法 DBSCAN 支持向量机 最大期望算法 决策树 Parzem窗设计 线性回归 局部加权线性回归 Ridge回归 Lasso最小回归系数估计 怎样选择算法使用机器学习算法的目的，想要算法完成何种任务 需要分析或收集的数据是什么 例如监督学习 Numpy库基础创建随机数组from numpy import * random.rand(4,4) 创建随机矩阵from numpy import * randMat = mat (random.rand(4,4)) randMat 逆矩阵randMat.I 存储矩阵invRandMat = randMat.I 矩阵相乘randMat*invRandMat 单位矩阵from numpy import * randMat = mat (random.rand(4,4)) randMat.I invRandMat = randMat.I randMat*invRandMat # 得误差值 myEye = randMat*invRandMat myEye - eye(4) k-近邻算法","categories":[],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://wenlwei.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}]},{"title":"Java类","slug":"Java类","date":"2021-12-14T13:51:50.000Z","updated":"2022-01-30T11:05:12.655Z","comments":true,"path":"posts/46779f67.html","link":"","permalink":"https://wenlwei.github.io/posts/46779f67.html","excerpt":"","text":"Java类字符串类字符串处理的类String，StringBuffer SringTokenizer StringBuilder StreamTokenozer String类String类定义的字符串是不可变长的。 String类是final类，是不可改变的，所以其创建对象的值无法改变。 String类中提供更改对象内容的方法并未真正更改内容，而是创建一个新的对象并返回。 字符串常量存储在常量池中，且常量唯一 直接引用字符串常量引用的是常量池中定义的常量，若无则创建。 通过构造方法创建，在堆内存中创建变量 exp： String str = new String(“Java”); exp：String str1=“Java”； ​ String str2=“Java”； str1,str2引用的是同一实体Java str1**==str2比较的是地址** String s1 = new String(“World”); String s2 = new String(“World”); String s3 = “World”; s1、s2分别在堆内存中分别创建一个World实体。 s1==s2不成立(地址) s2==s3不成立(地址) s2.equals(s3)成立 String对象是不可变的s1=“Hello”； s1=“Hello Java” 创建了一个新的对象 “Hello Java”，而原来的 “Hello” 还存在于内存中 String类常用方法 返回类型 方法名 功能 Sting() 创建一个空字符串对象 String(char value) 用字符数组value创建一个字符串对象 String(String str) 用字符串对象创建一个心的字符串对象 char[] toCharArray() 将字符串转化为字符数组 cahr charAt(int i) 返回指定索引位置的值 int compare To(String str) 按字典序比较两个字符串 String concat(String str) 将str连接到当前字符串末尾 boolean contains(CharSequence s) 此字符串包含char值序列s返回true boolean equals(Object obj) 当前字符串与对象比较 boolean isEmpty() 判断字符串是否为空 int index Of(String str) 返回当前字符串第一次出现str的索引 int length() 返回当前字符串的长度 boolean matches(String regex) 判断当前串是否匹配正则表达式 String replace(char&nbsp;old, char&nbsp;new) 对字符串中所有字符old替换为new Sting[] split(String regex) 按给定正则表达式的匹配拆分字符串 boolean tartsWith(String prefix) 判断当前串是否以prefix开头 String substring(int&nbsp;begin, int&nbsp;end) 返回当前字符串的一个子字符串 String trim() 删除前导空格和尾部空格 static String valueOf(Object obj) 返回 Object 参数的字符串表示形式 String str1 = new String(\"abc\"); String str2 = new String(\"abc\"); System.out.println(str1 == str2); System.out.println(str1.equals(str2)); 运行结果： false true String str1 = \"hello\"; String str2 = \"java\"; int result = str1.compareTo(str2); System.out.println(result); 运行结果：返回第一个不相等字符的ASCII之差 -2 String str1 = \"how are you!\"; int x = 97; //a的ASCII值 int index = str1.indexOf(x); System.out.println(index); 运行结果: 4 String str1 = \"end line,end line\"; String str2 = str1.replace('e', 'a'); System.out.println(str2); str2 = str1.replaceAll(\"end\", \"start\"); System.out.println(str3); 运行结果： and lina,and lina start line,start line String str1 = \"I am a student\"; String str2 = str1.substring(5); System.out.println(str2); 运行结果： a student String str1 = \"I am a student\"; String str2 = str1.substring(2,8); System.out.println(str2); 运行结果： am a s String str1 = \"hello java world\"; String[] str2 = str1.split(\" \"); for(String s : str2){ System.out.println(s); } 运行结果： hello java world StringBufferStringBuffer类定义的字符串是变长的。 StringBuffer类创建对象的值允许改变，用于字符串动态变化。 常用方法包括字符串尾部追加、插入、内容替换、字符串中删除子串、字符串倒序、返回缓冲区容量等 StringBuffer类常用方法 返回类型 方法名 功能 StringBuffer() 构造一个16字符的字符串缓冲区 StringBuffer(int a) 构造一指定容量的字符串缓冲区 StringBuffer(String str) 构造一指定串str另加16字符的缓冲区 StringBuffer(CharSequence s) 构造一字符序列s另加16字符的缓冲区 String toString() 转换为String字符串 StringBuffer append(String str) 追加字符串 StringBuffer insert(int offset, String str) 指定位置插入字符串 StringBuffer reverse() 字符翻转 StringBuffer delete(int startIndex,int endIndex) 删除startIndex与endIndex（不包括）之间的字符 StringBuffer replace(int startIndex,int endIndex,String str) 用str替换startIndex与endIndex（不包括）之间的字符 StringBuffer buffer = new StringBuffer(); System.out.println(buffer.toString()); buffer.append(\"JDK\");//末尾追加 buffer.append(8.0); System.out.println(buffer.toString()); buffer.insert(0, \"Hello \");//指定位置插入 System.out.println(buffer.toString()); buffer.delete(9, 12);//删除指定位置之间 System.out.println(buffer.toString()); 运行结果： JDK8.0 Hello JDK8.0 Hello JDK StringBuffer buffer = new StringBuffer(\"Hello Java!\"); System.out.println(buffer.toString()); buffer.replace(6, 11, \"Python\");//替换 System.out.println(buffer.toString()); buffer.reverse();//翻转 System.out.println(buffer.toString());运行结果： Hello Java! Hello Python nohtyP olleH StringBuilderStringBuilder和StringBuffer方法类似。 StringBuffer 的方法是线程安全的（不能同步访问），而StringBuilder不是。 String与StringBuffer比较构造方法不同String创建的字符串是常量，创建后不能改变； StringBuffer创建的是缓冲区，其字符串可以改变。 成员方法不同String类的成员方法以只读数据为主； StringBuffer的成员方法则可以读写字符串。 StringTokenizer类用于字符串分割，同时支持多种分隔符。 属于java.util包 构造方法StringTokenizer（String s），分隔标记默认为空格 StringTokenizer（String s, String delim），delim中的字符的任意排列组合都是分隔标记 public int countTokens()；// 分割串的个数 public boolean hasMoreTokens()；// 是否还有分割串 public String nextToken()；// 得到下一分割串 exp： import java.util.StringTokenizer; public class Main { public static void main(String[] args) { String s = \"I am Jame ,,, you are Jerry,and he is Tom\"; StringTokenizer tokenizer= new StringTokenizer(s,\" ,\");//空格、逗号 int number = tokenizer.countTokens();// 获取单词总数 while (tokenizer.hasMoreTokens()){// 是否还有单词 String str = tokenizer.nextToken();// 获得下一个单词 System.out.println(str); } System.out.println(\"总共单词数：\" + number); } } 运行结果： I am Jame you are Jerry and he is Tom 总共单词数：10 数学类Math（数学类） Random（随机数类） Math用于数学计算 Math类的所有属性和方法都是静态的 常用方法：取绝对值abs()、求最大值max()、求最小值min()、产生随机数random()、乘幂pow()、平方根sqrt()、对数log()、三角函数运算。 Random用于产生随机数 常用方法：支持基本类型随机数的产生。包括nextBoolean()、nextBytes()、nextDouble()、nextInt()、nextInt(int n)、nextLong()、setSeed()等。 exp： import java.util.Random; public class Main { public static void main(String[] args) { Random r = new Random(); int number = r.nextInt(10); System.out.println(number); } } 运行结果： 7 Date类Date类在包java.util 常用方法 返回类型 方法名 功能 Date() 构造方法，获取系统日期 boolean after(Date d) 测试此日期是否在指定日期之后 boolean before(Date d) 测试此日期是否在指定日期之前 int compareTo(Date d) 比较两个日期的顺序 long getTime() 返回自格林尼治GMT1970年1月1日00:00:00以来此 Date 对象表示的毫秒数 Calendar类日历类Calendar定义在java.util包 常用方法 返回类型 方法名 功能 int get(int field) 返回给定日历字段的值 Date getTime() 返回一个表示此Calemder时间值的Date对象 long getTimeInMillis() 返回以毫秒为单位的此日历的时间值 void set(int field,int value) 将给定的日历字段设置为给定值 void setTime(Date date) 使用给定的Date实例设置此Calender对象的时间 日期格式化格式化日期SimpleDateFormat类在包java.text 常用方法 返回类型 方法名 功能 SimpleDateFormat(String pattern) 构造方法，设置格式化日期格式 String format(Date date) 格式化日期并返回字符串 Date parse(String source) 指定格式字符串转换为Date对象 exp： import java.text.ParseException; import java.text.SimpleDateFormat; import java.util.Date; public class Main { public static void main(String[] args) { Date date = new Date(); System.out.println(date.toString()); SimpleDateFormat formater = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"); System.out.println(formater.format(date)); try { date = formater.parse(\"2021-12-14 21:16:30\"); System.out.println(date.toString()); } catch (ParseException e) {} } } 运行结果： Tue Dec 14 21:17:47 CST 2021 2021-12-14 21:17:47 Tue Dec 14 21:16:30 CST 2021 import java.text.ParseException; import java.text.SimpleDateFormat; import java.util.Calendar; import java.util.Date; public class Main { public static void main(String[] args) { Calendar calendar = Calendar.getInstance(); Date date = new Date(); System.out.println(date.toString()); calendar.setTime(date); int month = calendar.get(Calendar.MONTH); System.out.println(month);//月份从0开始 calendar.set(Calendar.MONTH,4); System.out.println(calendar.getTime()); } } 运行结果： Tue Dec 14 21:20:48 CST 2021 11 Fri May 14 21:20:48 CST 2021 集合类特点空间自主调整，提高空间利用率，动态存储多个对象。 提供不同的数据结构和算法，减少编程工作量。 提高程序的处理速度和质量。 注意：1.集合类支持引用类型，包括包装类。 2.集合类中存放的是对象的引用，而不是对象本身。 集合类均采用泛型进行定义，分为 Collection 和 Map 两种体系 泛型泛型允许类的成员的类型可以由外部程序来指定，也就是说可以以参数形式来指定类型，即“参数化类型”。常用泛型有泛型接口、泛型类、泛型方法。 泛型类定义class 泛型类名&lt;类型参数表列&gt;{//类体} public class ArrayList&lt;E&gt; { } 泛型接口定义interface 接口名&lt;类型参数表列&gt;{} public interface List&lt;E&gt;{ } 泛型方法定义[&lt;泛型参数&gt;] 方法类型 方法名([泛型参数]){} public boolean add(E e){ } Collection接口List：元素有序，可重复的集合 Set：元素无序、不可重复的集合 Collection 接口是 List、Set 接口的父接口，该接口里定义的方法既可用于操作 Set 集合，也可用于操作 List 集合。 Collection接口方法 类型 方法名 功能 void clear() 删除当前集合中的所有元素 boolean contains(Object o) 查找当前集合中是否有指定元素 boolean containsAll(Collection c) 查找当前集合中是否包含指定集合中的所有元素 boolean isEmpty() 当前集合是否为空 int size() 返回当前集合的元素个数 Iterator iterator() 返回一个可遍历当前集合的迭代器 Object[] toArray() 返回一个当前集合所有元素的数组 boolean add(E e) 向集合中添加新元素 boolean addAll(Collection c) 将指定集合中的所有元素添加到当前集合中 boolean remove(Object o) 删除当前集合中包含的指定元素 boolean removeAll(Collection c) 删除当前集合中与指定集合相同的所有元素 boolean retainAll(Collection c) 保留当前集合中与指定集合相同的所有元素 Map接口具有映射关系“key-value对”的集合 List集合List接口List集合接口，也称之为线性表，是一个有序列表。 集合中的元素是顺序存储，可以通过下标访问。 List集合中允许出现重复元素。 实现List集合接口的常用类：ArrayList、LinkedList、Vector和Stack 主要方法 类型 方法名 功能 boolean add(E e) 把元素e加到表的尾部 void add(int index,E e) 把元素e加到表的index位置，原位置元素后移 boolean equals(Object obj) 比较对象o是否与表中的元素是同一元素 E get(int index) 得到表中index位置的元素 int indexOf(Object o) 判断元素o是否存在，若不则返回-1 Iteratot iterator() 获得表的遍历器 E set(int index,E e) 修改位置上的元素 ArrayList集合类使用数组方式实现List接口 检索效率很高 删除效率很低 即数据结构的顺序表 主要方法 类型 方法名 功能 ArrayList() 构造一个初始容量为10的空列表 ArrayList(Collection c) 构造一个包含指定collectiong的元素列表 ArrayList(int capacity) 构造一个具有指定初始容量的空列表 Boolean add(E e) 把元素e加到表的尾部 E get(int index) 得到表中index位置的元素 boolean indexOf(Object o) 判断元素o是否存在，若不则返回-1 Iterator iterator 获得表的遍历器 import java.util.ArrayList; import java.util.Scanner; public class Main { public static void main(String[] args) { ArrayList&lt;Integer&gt; list =new ArrayList&lt;Integer&gt;(); list.add(1); list.add(3); list.add(5); list.add(7); for (int i=0;i&lt;list.size();i++){ System.out.print(list.get(i)+\",\"); } System.out.println(); list.remove(0); System.out.println(\"The second item = \" + list.get(1)); } } 运行结果： 1，3，5，7 The seconditem = 5 LinkedList集合类使用双向链表方式实现List接口，以及队列Deque接口 删除效率很高 检索效率很低 表示线性序列表，也可以表示堆栈使用，还可以当做队列使用。 主要方法 类型 方法名 功能 LinkedList() 构造一个初始容量为 10 的空列表 LinkedList(Collection c) 构造一个包含指定 collection 的元素的列表 void aa(int index,E element) 把元素e插入到列表index所指位置，并依次后移 boolean add(E e) 把元素e加到表的尾部 boolean indexOf(Object o) 判断元素o在表中是否存在。若不存在，则返回-1 void addFirst(E e) 将元素e插入到列表的头部 E getFirst() 返回列表的头部元素 E removeFirst 从列表中删除头部元素并返回该元素 E pop() 栈顶元素出栈 void push(E e) 元素e入栈 import java.util.ArrayList; import java.util.LinkedList; import java.util.Scanner; public class Main { public static void main(String[] args) { LinkedList&lt;String&gt; list = new LinkedList&lt;String&gt;(); list.add(\"A\"); list.add(\"B\"); list.add(\"C\"); list.add(\"D\"); list.remove(\"C\"); list.addFirst(\"E\"); for(String s : list) { System.out.println(s); }//foreach遍历 } } 运行结果： E A B D Vector集合类是一种动态数组，元素只能是对象 对象类型可以不同 与ArrayList、LinkedList相比，线程安全 通过synchronized关键字修饰方法，实现线程安全 类型 方法名 功能 Vector() 构造一个初始容量为 10 的空列表 Vector(Collection c) 构造一个包含指定 collection 的元素的列表 boolean add(E e) 把元素e加到表的尾部 int indexOf(Object o) 判断元素o在表中是否存在。若不存在，则返回-1 synchronized void addElement(E obj) 将元素e同步插入到列表的尾部 synchronized void removeElement(Object obj) 同步删除元素obj synchronized void insertElementAt(E obj,int index) 在index位置同步插入元素obj synchronized void firstElement() 同步返回第一个元素 import java.util.ArrayList; import java.util.LinkedList; import java.util.Scanner; import java.util.Vector; public class Main { public static void main(String[] args) { Vector v = new Vector(); v.add(\"Hello\"); v.add(\"JDK\"); v.addElement(8.0); for(int i = 0; i &lt; v.size();i++){ System.out.println(v.get(i)); } } } 运行结果： Hello JDK 8.0 Set集合Set集合中元素无序，不重复 方法与Collection相同 实现Set集合接口的类：HashSet、TreeSet 主要方法 HashSet集合类集合中元素无序 元素不重复 元素值可以为空（null） 存储每个元素时会生成一个唯一的整数标识——散列码（hash code），HashSet根据散列码来决定元素所在的存储位置 主要方法 import java.util.HashSet; import java.util.Iterator; public class Main { public static void main(String[] args) { HashSet&lt;String&gt; set = new HashSet&lt;String&gt;(); set.add(\"one\"); set.add(\"two\"); set.add(\"tree\"); set.add(\"one\");//set中存放one,two,three,且无序不重复 System.out.println(set.size()); Iterator&lt;String&gt; iterator = set.iterator(); while(iterator.hasNext()){ System.out.println(iterator.next()); } } } 运行结果： 3 one tree two TreeSet集合类集合中元素有序：采用二叉搜索树的数据结构进行元素的存储，按照树形层次排列，会按其存放的数据的“大小”顺序一层一层地依次排列 元素不重复 存储的元素类型必须是可排序的 主要方法 import java.util.Iterator; import java.util.TreeSet; public class Main { public static void main(String[] args) { TreeSet&lt;String&gt; treeSet = new TreeSet&lt;String&gt;(); treeSet.add(\"banana\"); treeSet.add(\"peach\"); treeSet.add(\"pineapple\"); treeSet.add(\"apple\"); System.out.println(treeSet.first()); System.out.println(treeSet.last()); Iterator&lt;String&gt; iterator = treeSet.iterator(); while(iterator.hasNext()){ System.out.println(iterator.next()); } } } 运行结果： apple pineapple apple banana peach pineapple Map集合用于存放一组成对的“键值对”对象 每个元素包括两部分：键（key）、值（value） 键（key）不能重复，值（value）可以重复 实现Set集合接口的类：HashMap、HashTree、HashTable 主要方法 HashMap集合类采用散列表数据结构存储数据 key-value存储 键（key）不能重复，值（value）可以重复 主要方法 包装类 系统类 其他常用类","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://wenlwei.github.io/tags/java/"}]}],"categories":[],"tags":[{"name":"python","slug":"python","permalink":"https://wenlwei.github.io/tags/python/"},{"name":"机器学习","slug":"机器学习","permalink":"https://wenlwei.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https://wenlwei.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"java","slug":"java","permalink":"https://wenlwei.github.io/tags/java/"},{"name":"Java","slug":"Java","permalink":"https://wenlwei.github.io/tags/Java/"}]}
{"meta":{"title":"wenlwei","subtitle":"wenlweiの博客","description":"本科","author":"wenlwei","url":"https://wenlwei.cn","root":"/"},"pages":[{"title":"404","date":"2019-08-10T08:41:10.000Z","updated":"2022-01-29T10:33:07.858Z","comments":true,"path":"404.html","permalink":"https://wenlwei.cn/404.html","excerpt":"","text":""},{"title":"","date":"2022-01-29T10:33:08.046Z","updated":"2022-01-29T10:33:08.046Z","comments":true,"path":"baidu_verify_xxxxxxx.html","permalink":"https://wenlwei.cn/baidu_verify_xxxxxxx.html","excerpt":"","text":"wvlc3L96QK"},{"title":"放松一下","date":"2019-08-10T08:41:10.000Z","updated":"2022-01-29T10:33:07.874Z","comments":true,"path":"List/index.html","permalink":"https://wenlwei.cn/List/index.html","excerpt":"","text":"影音资源共享"},{"title":"","date":"2022-01-29T10:33:08.046Z","updated":"2022-01-29T10:33:08.046Z","comments":true,"path":"google1xxxxxxx0.html","permalink":"https://wenlwei.cn/google1xxxxxxx0.html","excerpt":"","text":"google-site-verification: google110e5e5e14c8dcf0.html"},{"title":"about","date":"2019-10-24T16:00:00.000Z","updated":"2022-01-29T10:33:08.046Z","comments":true,"path":"about/index.html","permalink":"https://wenlwei.cn/about/index.html","excerpt":"","text":""},{"title":"archives","date":"2019-10-24T16:00:00.000Z","updated":"2022-01-29T10:33:08.046Z","comments":true,"path":"archives/index.html","permalink":"https://wenlwei.cn/archives/index.html","excerpt":"","text":""},{"title":"统计","date":"2020-10-31T02:11:28.000Z","updated":"2022-01-29T10:33:08.046Z","comments":true,"path":"census/index.html","permalink":"https://wenlwei.cn/census/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-10-24T16:00:00.000Z","updated":"2022-01-29T10:33:08.046Z","comments":true,"path":"categories/index.html","permalink":"https://wenlwei.cn/categories/index.html","excerpt":"","text":""},{"title":"留言板","date":"2019-10-24T16:00:00.000Z","updated":"2022-01-29T12:39:22.868Z","comments":true,"path":"contact/index.html","permalink":"https://wenlwei.cn/contact/index.html","excerpt":"","text":"畅所欲言 在这里可以留下你的足迹，欢迎在下方留言，欢迎交换友链，一起交流学习！ 友链 wenlweiの友链信息 博客名称: wenlweiの博客 博客网址: wenlwei 博客头像: https://s4.ax1x.com/2022/01/29/HpyLa4.jpg 博客介绍: The harder you work, the luckier you will be"},{"title":"友链","date":"2019-07-19T08:42:10.000Z","updated":"2022-01-29T10:33:08.046Z","comments":true,"path":"friends/index.html","permalink":"https://wenlwei.cn/friends/index.html","excerpt":"","text":""},{"title":"资源分享","date":"2019-07-19T08:40:27.000Z","updated":"2022-01-29T10:33:08.062Z","comments":true,"path":"resource/index.html","permalink":"https://wenlwei.cn/resource/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-07-19T08:40:27.000Z","updated":"2022-01-29T10:33:08.062Z","comments":true,"path":"tags/index.html","permalink":"https://wenlwei.cn/tags/index.html","excerpt":"","text":""},{"title":"相册","date":"2022-01-29T10:33:07.858Z","updated":"2022-01-29T10:33:07.858Z","comments":true,"path":"List/galleries/index.html","permalink":"https://wenlwei.cn/List/galleries/index.html","excerpt":"","text":""},{"title":"视频","date":"2019-08-10T08:41:10.000Z","updated":"2022-01-29T10:33:07.874Z","comments":true,"path":"List/movies/index.html","permalink":"https://wenlwei.cn/List/movies/index.html","excerpt":"","text":""},{"title":"听听音乐","date":"2019-07-19T08:40:27.000Z","updated":"2022-01-29T10:33:07.874Z","comments":true,"path":"List/tools/index.html","permalink":"https://wenlwei.cn/List/tools/index.html","excerpt":"","text":""},{"title":"听听音乐","date":"2019-07-19T08:40:27.000Z","updated":"2022-01-29T10:33:07.874Z","comments":true,"path":"List/music/index.html","permalink":"https://wenlwei.cn/List/music/index.html","excerpt":"","text":""},{"title":"乖巧小狗","date":"2022-01-29T10:33:07.874Z","updated":"2022-01-29T10:33:07.874Z","comments":true,"path":"List/galleries/乖巧小狗/index.html","permalink":"https://wenlwei.cn/List/galleries/%E4%B9%96%E5%B7%A7%E5%B0%8F%E7%8B%97/index.html","excerpt":"","text":""},{"title":"动漫人物","date":"2022-01-29T10:33:07.874Z","updated":"2022-01-29T10:33:07.874Z","comments":true,"path":"List/galleries/动漫人物/index.html","permalink":"https://wenlwei.cn/List/galleries/%E5%8A%A8%E6%BC%AB%E4%BA%BA%E7%89%A9/index.html","excerpt":"","text":""},{"title":"二次元风","date":"2022-01-29T10:33:07.874Z","updated":"2022-01-29T10:33:07.874Z","comments":true,"path":"List/galleries/二次元风/index.html","permalink":"https://wenlwei.cn/List/galleries/%E4%BA%8C%E6%AC%A1%E5%85%83%E9%A3%8E/index.html","excerpt":"","text":""},{"title":"动漫插画","date":"2022-01-29T10:33:07.874Z","updated":"2022-01-29T10:33:07.874Z","comments":true,"path":"List/galleries/动漫插画/index.html","permalink":"https://wenlwei.cn/List/galleries/%E5%8A%A8%E6%BC%AB%E6%8F%92%E7%94%BB/index.html","excerpt":"","text":""},{"title":"动漫风景","date":"2022-01-29T10:33:07.874Z","updated":"2022-01-29T10:33:07.874Z","comments":true,"path":"List/galleries/动漫风景/index.html","permalink":"https://wenlwei.cn/List/galleries/%E5%8A%A8%E6%BC%AB%E9%A3%8E%E6%99%AF/index.html","excerpt":"","text":""},{"title":"呆萌猫咪","date":"2022-01-29T10:33:07.874Z","updated":"2022-01-29T10:33:07.874Z","comments":true,"path":"List/galleries/呆萌猫咪/index.html","permalink":"https://wenlwei.cn/List/galleries/%E5%91%86%E8%90%8C%E7%8C%AB%E5%92%AA/index.html","excerpt":"","text":""},{"title":"清新花卉","date":"2022-01-29T10:33:07.874Z","updated":"2022-01-29T10:33:07.874Z","comments":true,"path":"List/galleries/清新花卉/index.html","permalink":"https://wenlwei.cn/List/galleries/%E6%B8%85%E6%96%B0%E8%8A%B1%E5%8D%89/index.html","excerpt":"","text":""},{"title":"城市风光","date":"2022-01-29T10:33:07.874Z","updated":"2022-01-29T10:33:07.874Z","comments":true,"path":"List/galleries/城市风光/index.html","permalink":"https://wenlwei.cn/List/galleries/%E5%9F%8E%E5%B8%82%E9%A3%8E%E5%85%89/index.html","excerpt":"","text":""},{"title":"璀璨星空","date":"2022-01-29T10:33:07.874Z","updated":"2022-01-29T10:33:07.874Z","comments":true,"path":"List/galleries/璀璨星空/index.html","permalink":"https://wenlwei.cn/List/galleries/%E7%92%80%E7%92%A8%E6%98%9F%E7%A9%BA/index.html","excerpt":"","text":""},{"title":"甜美食品","date":"2022-01-29T10:33:07.874Z","updated":"2022-01-29T10:33:07.874Z","comments":true,"path":"List/galleries/甜美食品/index.html","permalink":"https://wenlwei.cn/List/galleries/%E7%94%9C%E7%BE%8E%E9%A3%9F%E5%93%81/index.html","excerpt":"","text":""},{"title":"炫酷跑车","date":"2022-01-29T10:33:07.874Z","updated":"2022-01-29T10:33:07.874Z","comments":true,"path":"List/galleries/炫酷跑车/index.html","permalink":"https://wenlwei.cn/List/galleries/%E7%82%AB%E9%85%B7%E8%B7%91%E8%BD%A6/index.html","excerpt":"","text":""},{"title":"自然风景","date":"2022-01-29T10:33:07.874Z","updated":"2022-01-29T10:33:07.874Z","comments":true,"path":"List/galleries/自然风景/index.html","permalink":"https://wenlwei.cn/List/galleries/%E8%87%AA%E7%84%B6%E9%A3%8E%E6%99%AF/index.html","excerpt":"","text":""}],"posts":[{"title":"","slug":"mysql基本操作","date":"2023-03-01T15:59:40.500Z","updated":"2023-03-01T16:09:09.212Z","comments":true,"path":"posts/0.html","link":"","permalink":"https://wenlwei.cn/posts/0.html","excerpt":"","text":"数据库操作查询数据库show datebases; 创建数据库#直接创建数据库 create datebase 数据库1; #判断创建，如果不存在数据库2就创建 create datebase if not exists 数据库2; 删除数据库drop datebase 数据库1; drop datebase if exists 数据库1; 查看当前正在使用的数据库select datebase(); 使用数据库use 数据库1 数据库表操作查询表# 查询所有表 show tables; # 查看表结构 desc 表名 创建表create table( 字段名 数据类型, 字段名 数据类型, ... 字段名 数据类型 ); 数据类型 删除表drop table 表名; drop table if exists 表名 修改表#修改表名 alter table 表名 rename to 新表名; #添加一列 alter table 表名 add 列名 数据类型; #修改数据类型 alter table 表名 modify 列名 新数据类型; #修改类名数据类型 alter table 表名 change 列名 新列名 新数据类型; #删除列 alter table 表名 drop 列名; 数据库数据操作添加数据#指定列添加数据 insert into 表名(列1,列2,...) valuse(值1,值2,...); #给全部列添加数据 insert into 表名 valuse(值1,值2,...); #批量添加数据 insert into 表名(列1,列2,...) values(值1,值2,...),(值1,值2,...),(值1,值2,...)...; insert into 表名 values(值1,值2,...),(值1,值2,...),(值1,值2,...)...; 修改表数据update 表名 set 列1=值1,列2=值2,...[where 条件]; # 不加条件将修改全部 删除数据delete from 表名 [where 条件] # 不加条件将删除全部 数据库查询操作查询多个字段select 字段列表 from 表名; select * from 表名;-- 查询所有数据 去除重复记录select distinct 字段列表 from 表名; 起别名#as[as可以省略] select name,math [as] 数学成绩,english from 表名; 条件查询select * from 表名 where 条件; #查询年龄15到20之间的人 select name from 表名 where age between 15 and 20; #查询年龄15或20的人 select name from 表名 where age = 15 or age = 20; select name from 表名 where age in(18,20); #查询成绩为null的人 select name from 表名 grade is null; #查询成绩不为null的人 select name from 表名 grade is not null; 模糊查询通配符： _:$\\textcolor{red}{代表单个任意字符}$ %:$\\textcolor{red}{代表任意个数的字符}$ #查询姓w的人 select * from 表名 where name like 'w%';; #查询第二个字是w的人 select * from 表名 where name like '_w%'; #查询名字包含w的人 select * from 表名 where name likr '%w%'; 排序查询select 字段列表 from 表名 order by 排序字段名1 [排序方式1],排序字段名2 [排序方式2]...; # 按年龄升序排列 select * from 表名 order by age; select * from 表名 order by age asc; # 按成绩排列如果成绩一样则按年龄升序排列 select * from 表名 order by grade desc,age asc 排序方式：ASC升序（默认方式） ​ DESC：降序 $\\textcolor{red}{如果有多个排序条件，当前面条件值一样时，才会按照第二天排序}$ 聚合函数聚合函数：将一列数据作为一个整体，进行纵向计算 select 聚合函数(列名) from 表名; $\\textcolor{red}{null值不参与所有聚合函数函数运算}$ 分组查询select 字段列表 from 表名 [where 分组前条件限定] group by 分组字段名 [having 分组后条件过滤] $\\textcolor{red}{分组之后，查询的字段为聚合函数和分组字段，查询其他字段无意义}$ $\\textcolor{red}{where和having的区别：}$ 执行时机不一样，where分组前，having分组后 ​ 判断条件不同，having可以对聚会函数判断，where不可以 执行顺序：where&gt;聚合函数&gt;having 分页查询select 字段列表 from 表名 limit 起始索引,查询条目数; 起始索引(从0开始)=(当前页码-1)*每页显示的条数 约束可以在$\\textcolor{red}{建表时添加约束，也可以建表后添加}$ ==建表后== # 非空和唯一约束 alter table 表名 modify 字段名 数据类型 关键字 # 主键约束 alter table 表名 add primary key(字段名) # 默认约束 alter table 表名 alter 列名 set default 默认值 # 检查约束 alter table 表名 add constraint 检查约束名· check(检查约束) # 外键约束 alter table 表名 add constraint 外键名称 foreign key (外键字段名称) references 主表名称(主表列名称) ==删除约束== # 非空约束 alter table 表名 modify 字段名 数据类型 # 唯一约束 alter table 表名 modify drop index 字段名 # 主键约束 alter table 表名 drop primary key # 默认约束 alter table 表名 alter 列名 drop default #检查约束 alter table 表名 drop constraint 检查约束名 # 外键约束 alter table 表名 drop foreign key 外键名称 非空约束关键字：NOT NULL create table stu( int age not null, #非空 ) 唯一约束关键字：UNIQUE create table stu( age int not null, # 非空 name varchar(50) not null unique, # 非空且唯一 ) 主键约束关键字：PRIMARY KEY create table stu( id int primary key auto_increment,# 主键且自增长 age int not null, # 非空 name varchar(50) not null unique, # 非空且唯一 ) 检查约束关键字：CHECK create table stu( id int primary key auto_increment,# 主键且自增长 age int not null, # 非空 name varchar(50) not null unique, # 非空且唯一 check(age &gt; 18 and age &lt; 60), ) 默认约束关键字：DEFAULT create table stu( id int primary key,# 主键且自增长 age int not null, # 非空 name varchar(50) not null unique, # 非空且唯一 bonus double(7,2) default 0 # 没有默认为0 ) 外键约束关键字：FOREIGN KEY create table stu( id int primary key,# 主键且自增长 age int not null, # 非空 name varchar(50) not null unique, # 非空且唯一 bonus double(7,2) default 0 # 没有默认为0 teache varchar(50) constraint 外键名称 foreign key(外键列名) refernnces 主表(主表列名) ) 两个表之间建立连接 表关系一对多一个部门对应多个员工 $\\textcolor{red}{在多的一方建立外表，指向一的一方主键}$ 多对多商品与订单 $\\textcolor{red}{建立第三张中间表，中间表至少包含两个外键，分别关联两方主键}$ 一对一用户和用户详情 多用于表的拆分，将一个实体中经常使用的字段放一张表，不常用的字段放一张表 $\\textcolor{red}{在任意一方加入外键，关联另一方的主键，并且外键唯一}$ 多表查询select * from 表1, 表2; -- 缺点会产生笛卡尔积：有A，B两个集合，去A，B所有组合情况 # 消除无效数据 select * from 表1, 表2 where 条件; -- 连接查询 # 内连接：查询A，B的交集 /* 外连接： 左外连接：相当于查询A表所有数据和交集部分数据 右外连接：相当于查询B表所有数据和交集部分数据 */ 内&amp;外连接# 隐式内连接 select 字段列表 from 表1, 表2... where 条件 # 显示内连接 select 字段列表 from 表1 [inner] join 表2 on 条件 # 左外连接 select 字段列表 from 表1 LEFT [outer] join 表2 on 条件 # 右外连接 select 字段列表 from 表1 right [outer] join 表2 on 条件 子查询（嵌套查询）# 单行单列：使用=!=&gt;&lt;等进行条件判断 select 字段列表 from 表 where 字段名 = (select ...); # 多行多列：使用in关键字进行条件判断 select 字段列表 from 表 where 字段名 in (子查询(select ...)); # 多行多列：作为虚拟表 select 字段列表 from (子查询) where 条件; 事务一种机制，一个操作序列，包含一组操作数据库指令 同时成功，同时失败 不可分开的工作逻辑单元 # 开启事务 start transaction或者begin # 提交事务 commit # 回滚事务（出异常时） rollback $\\textcolor{red}{事务四大特征}$: 1. 原子性：最小操作单位，同时成功同时失败 2. 一致性：事务完成时，所有数据都保持一致状态 3. 隔离性：多个事务之间，操作的可见性 4. 持久性：事务一旦提交或回滚，对数据库中数据的改变是永久的","categories":[],"tags":[]},{"title":"KNN","slug":"KNN","date":"2022-02-28T08:13:10.000Z","updated":"2022-02-28T11:50:58.135Z","comments":true,"path":"posts/7c10b52f.html","link":"","permalink":"https://wenlwei.cn/posts/7c10b52f.html","excerpt":"","text":"什么是KNNK近邻（KNN）算法是一种分类和回归算法，一个未知样本与数据集中的K个样本最相似，如果这K个样本中的大多数属于一类，则这未知样本也属于该类 简单的说就是每个样本都可以用与他最近的K个邻居来代表 KNN算法 步骤 收集数据 以所有已知类实例作为参照选择参数K 计算未知实例与所有已知实例的距离 选择最近的K个实例（一般取奇数，偶数容易会出现误差） 判断未知实例属于哪一个类 判断距离 欧式距离 马氏距离 曼哈顿距离 优缺点优点：精度高，对异常值不敏感，无数据输入假定 缺点：计算复杂度高，空间复杂度高；在样本分布不平衡时，大样本占主导地位 Python实现 电影名称 打斗镜头 接吻镜头 电影类型 Californian Man 3 104 爱情片 He’s Not Really into Dudes 2 100 爱情片 Beautiful Woman 1 81 爱情片 Kevin Longblade 101 10 动作片 RobotSlayer 3000 99 5 动作片 Amped 2 98 2 动作片 ？ 18 90 未知 注：样例来自《机器学习实战》 先将样例画出散点图很容易判断？属于爱情片 \"\"\" 作者：wenlwei \"\"\" import numpy as np import matplotlib.pyplot as plt import operator # 爱情篇的打斗镜头 x_1 = np.array([3, 2, 1]) # 爱情篇的接吻镜头 y_1 = np.array([104, 100, 81]) # 动作片的打斗镜头 x_2 = np.array([101, 99, 98]) # 动作片的接吻镜头 y_2 = np.array([10, 5, 2]) # 未知样例 x_3 = np.array([18]) y_3 = np.array([90]) # 散点图 scatter_1 = plt.scatter(x_1, y_1, c = 'g') scatter_2 = plt.scatter(x_2, y_2, c = 'r') scatter_3 = plt.scatter(x_3, y_3, c = 'k') # 画图，标签 plt.legend(handles = [scatter_1, scatter_2, scatter_3], labels = ['A', 'B', 'X'], loc = 'best') plt.show() 算法实现 \"\"\" 作者：wenlwei \"\"\" import numpy as np import matplotlib.pyplot as plt import operator # 已知数据，标签，未知数据 x_data = np.array([[3, 104], [2, 100], [1, 81], [101, 10], [99, 5], [98, 2]]) y_label = np.array(['A', 'A', 'A', 'B', 'B', 'B']) x_test = np.array([18, 90]) # 已知样本数量 x_data_size = x_data.shape[0] # 因为要计算未知样例与所有样例的距离所有需要复制x_test # 行复制x_data_size次，列复制1次 diffMat = np.tile(x_test, (x_data_size, 1)) - x_data # 插值的平方 sq_diffMat = diffMat**2 # 求和 sq_sum = sq_diffMat.sum(axis=1) # 开方 sqrt_sq_sum = sq_sum**0.5 # 按升序排序 ''' argsort函数返回的是索引 例：array = [12, 10, 45, 11, 13] 排序后为array = [1, 3, 0, 4, 2] 分别对应10，11，12，13，45 ''' sort_sqrt_sq_sum = sqrt_sq_sum.argsort() # 定义一个空字典，记录标签 classCount = {} # 设K=3 for i in range(3): # 获取标签 votelabel = y_label[sort_sqrt_sq_sum[i]] # 如果不存在就get(0) classCount[votelabel] = classCount.get(votelabel, 0) + 1 # 对classCount排序,True表示倒叙 sortedclassCount = sorted(classCount.items(), key=operator.itemgetter(1), reverse=True) # 获取最多的标签判断x_test knn = sortedclassCount[0][0] print(knn) 运行结果： A 通过结果可以知道knn=A，即？距离k个样例中爱情片最近 参考文献: 《机器学习实战》","categories":[],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://wenlwei.cn/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}]},{"title":"机器学习","slug":"机器学习","date":"2021-12-16T14:51:18.000Z","updated":"2022-01-30T11:15:58.043Z","comments":true,"path":"posts/498ab7d9.html","link":"","permalink":"https://wenlwei.cn/posts/498ab7d9.html","excerpt":"","text":"机器学习机器学习基础什么是机器学习？ 通过对信息的统计来利用信息建立模型然后使用模型预测的方法。即将大量的数据转换成有用的信息。 为什么要进行机器学习？ 机器学习的主要任务：回归，分类 分类：将实例数据进行合适分类 回归：主要用于预测数值型数据 训练集：拥有已大量分类的数据，是用于训练机器学习算法的数据样本集合 目标变量：是机器学习算法的预测结果，分类算法中目标变量通常是标称型，回归算法中通常是连续型 注意：特征或属性通常是训练样本集的列，是独立测量得到的结果，多个特征联系在一起共同组成一个训练样本 训练数据：机器学习开始时作为算法输入的训练样本集 测试数据：训练完成后输入的训练样本集 注：测试样本时不提供目标变量，由程序决定 分类和回归都称为监督学习，这类算法必须知道要预测什么，即目标变量的分类信息 无监督学习即数据没有类别信息，也不给定目标值 聚类：无监督学习中，将数据集合分成类似的对象组成的多个类的过程 密度估计：寻找描述数据统计值的过程 无监督学习可以减少数据特征的维度 监督学习的用途 无监督学习的用途 k-近邻算法 K-均值 朴素贝叶斯算法 DBSCAN 支持向量机 最大期望算法 决策树 Parzem窗设计 线性回归 局部加权线性回归 Ridge回归 Lasso最小回归系数估计 怎样选择算法使用机器学习算法的目的，想要算法完成何种任务 需要分析或收集的数据是什么 例如监督学习 Numpy库基础创建随机数组from numpy import * random.rand(4,4) 创建随机矩阵from numpy import * randMat = mat (random.rand(4,4)) randMat 逆矩阵randMat.I 存储矩阵invRandMat = randMat.I 矩阵相乘randMat*invRandMat 单位矩阵from numpy import * randMat = mat (random.rand(4,4)) randMat.I invRandMat = randMat.I randMat*invRandMat # 得误差值 myEye = randMat*invRandMat myEye - eye(4) k-近邻算法","categories":[],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://wenlwei.cn/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}]},{"title":"Java类","slug":"Java类","date":"2021-12-14T13:51:50.000Z","updated":"2022-01-30T11:05:12.655Z","comments":true,"path":"posts/46779f67.html","link":"","permalink":"https://wenlwei.cn/posts/46779f67.html","excerpt":"","text":"Java类字符串类字符串处理的类String，StringBuffer SringTokenizer StringBuilder StreamTokenozer String类String类定义的字符串是不可变长的。 String类是final类，是不可改变的，所以其创建对象的值无法改变。 String类中提供更改对象内容的方法并未真正更改内容，而是创建一个新的对象并返回。 字符串常量存储在常量池中，且常量唯一 直接引用字符串常量引用的是常量池中定义的常量，若无则创建。 通过构造方法创建，在堆内存中创建变量 exp： String str = new String(“Java”); exp：String str1=“Java”； ​ String str2=“Java”； str1,str2引用的是同一实体Java str1**==str2比较的是地址** String s1 = new String(“World”); String s2 = new String(“World”); String s3 = “World”; s1、s2分别在堆内存中分别创建一个World实体。 s1==s2不成立(地址) s2==s3不成立(地址) s2.equals(s3)成立 String对象是不可变的s1=“Hello”； s1=“Hello Java” 创建了一个新的对象 “Hello Java”，而原来的 “Hello” 还存在于内存中 String类常用方法 返回类型 方法名 功能 Sting() 创建一个空字符串对象 String(char value) 用字符数组value创建一个字符串对象 String(String str) 用字符串对象创建一个心的字符串对象 char[] toCharArray() 将字符串转化为字符数组 cahr charAt(int i) 返回指定索引位置的值 int compare To(String str) 按字典序比较两个字符串 String concat(String str) 将str连接到当前字符串末尾 boolean contains(CharSequence s) 此字符串包含char值序列s返回true boolean equals(Object obj) 当前字符串与对象比较 boolean isEmpty() 判断字符串是否为空 int index Of(String str) 返回当前字符串第一次出现str的索引 int length() 返回当前字符串的长度 boolean matches(String regex) 判断当前串是否匹配正则表达式 String replace(char&nbsp;old, char&nbsp;new) 对字符串中所有字符old替换为new Sting[] split(String regex) 按给定正则表达式的匹配拆分字符串 boolean tartsWith(String prefix) 判断当前串是否以prefix开头 String substring(int&nbsp;begin, int&nbsp;end) 返回当前字符串的一个子字符串 String trim() 删除前导空格和尾部空格 static String valueOf(Object obj) 返回 Object 参数的字符串表示形式 String str1 = new String(\"abc\"); String str2 = new String(\"abc\"); System.out.println(str1 == str2); System.out.println(str1.equals(str2)); 运行结果： false true String str1 = \"hello\"; String str2 = \"java\"; int result = str1.compareTo(str2); System.out.println(result); 运行结果：返回第一个不相等字符的ASCII之差 -2 String str1 = \"how are you!\"; int x = 97; //a的ASCII值 int index = str1.indexOf(x); System.out.println(index); 运行结果: 4 String str1 = \"end line,end line\"; String str2 = str1.replace('e', 'a'); System.out.println(str2); str2 = str1.replaceAll(\"end\", \"start\"); System.out.println(str3); 运行结果： and lina,and lina start line,start line String str1 = \"I am a student\"; String str2 = str1.substring(5); System.out.println(str2); 运行结果： a student String str1 = \"I am a student\"; String str2 = str1.substring(2,8); System.out.println(str2); 运行结果： am a s String str1 = \"hello java world\"; String[] str2 = str1.split(\" \"); for(String s : str2){ System.out.println(s); } 运行结果： hello java world StringBufferStringBuffer类定义的字符串是变长的。 StringBuffer类创建对象的值允许改变，用于字符串动态变化。 常用方法包括字符串尾部追加、插入、内容替换、字符串中删除子串、字符串倒序、返回缓冲区容量等 StringBuffer类常用方法 返回类型 方法名 功能 StringBuffer() 构造一个16字符的字符串缓冲区 StringBuffer(int a) 构造一指定容量的字符串缓冲区 StringBuffer(String str) 构造一指定串str另加16字符的缓冲区 StringBuffer(CharSequence s) 构造一字符序列s另加16字符的缓冲区 String toString() 转换为String字符串 StringBuffer append(String str) 追加字符串 StringBuffer insert(int offset, String str) 指定位置插入字符串 StringBuffer reverse() 字符翻转 StringBuffer delete(int startIndex,int endIndex) 删除startIndex与endIndex（不包括）之间的字符 StringBuffer replace(int startIndex,int endIndex,String str) 用str替换startIndex与endIndex（不包括）之间的字符 StringBuffer buffer = new StringBuffer(); System.out.println(buffer.toString()); buffer.append(\"JDK\");//末尾追加 buffer.append(8.0); System.out.println(buffer.toString()); buffer.insert(0, \"Hello \");//指定位置插入 System.out.println(buffer.toString()); buffer.delete(9, 12);//删除指定位置之间 System.out.println(buffer.toString()); 运行结果： JDK8.0 Hello JDK8.0 Hello JDK StringBuffer buffer = new StringBuffer(\"Hello Java!\"); System.out.println(buffer.toString()); buffer.replace(6, 11, \"Python\");//替换 System.out.println(buffer.toString()); buffer.reverse();//翻转 System.out.println(buffer.toString());运行结果： Hello Java! Hello Python nohtyP olleH StringBuilderStringBuilder和StringBuffer方法类似。 StringBuffer 的方法是线程安全的（不能同步访问），而StringBuilder不是。 String与StringBuffer比较构造方法不同String创建的字符串是常量，创建后不能改变； StringBuffer创建的是缓冲区，其字符串可以改变。 成员方法不同String类的成员方法以只读数据为主； StringBuffer的成员方法则可以读写字符串。 StringTokenizer类用于字符串分割，同时支持多种分隔符。 属于java.util包 构造方法StringTokenizer（String s），分隔标记默认为空格 StringTokenizer（String s, String delim），delim中的字符的任意排列组合都是分隔标记 public int countTokens()；// 分割串的个数 public boolean hasMoreTokens()；// 是否还有分割串 public String nextToken()；// 得到下一分割串 exp： import java.util.StringTokenizer; public class Main { public static void main(String[] args) { String s = \"I am Jame ,,, you are Jerry,and he is Tom\"; StringTokenizer tokenizer= new StringTokenizer(s,\" ,\");//空格、逗号 int number = tokenizer.countTokens();// 获取单词总数 while (tokenizer.hasMoreTokens()){// 是否还有单词 String str = tokenizer.nextToken();// 获得下一个单词 System.out.println(str); } System.out.println(\"总共单词数：\" + number); } } 运行结果： I am Jame you are Jerry and he is Tom 总共单词数：10 数学类Math（数学类） Random（随机数类） Math用于数学计算 Math类的所有属性和方法都是静态的 常用方法：取绝对值abs()、求最大值max()、求最小值min()、产生随机数random()、乘幂pow()、平方根sqrt()、对数log()、三角函数运算。 Random用于产生随机数 常用方法：支持基本类型随机数的产生。包括nextBoolean()、nextBytes()、nextDouble()、nextInt()、nextInt(int n)、nextLong()、setSeed()等。 exp： import java.util.Random; public class Main { public static void main(String[] args) { Random r = new Random(); int number = r.nextInt(10); System.out.println(number); } } 运行结果： 7 Date类Date类在包java.util 常用方法 返回类型 方法名 功能 Date() 构造方法，获取系统日期 boolean after(Date d) 测试此日期是否在指定日期之后 boolean before(Date d) 测试此日期是否在指定日期之前 int compareTo(Date d) 比较两个日期的顺序 long getTime() 返回自格林尼治GMT1970年1月1日00:00:00以来此 Date 对象表示的毫秒数 Calendar类日历类Calendar定义在java.util包 常用方法 返回类型 方法名 功能 int get(int field) 返回给定日历字段的值 Date getTime() 返回一个表示此Calemder时间值的Date对象 long getTimeInMillis() 返回以毫秒为单位的此日历的时间值 void set(int field,int value) 将给定的日历字段设置为给定值 void setTime(Date date) 使用给定的Date实例设置此Calender对象的时间 日期格式化格式化日期SimpleDateFormat类在包java.text 常用方法 返回类型 方法名 功能 SimpleDateFormat(String pattern) 构造方法，设置格式化日期格式 String format(Date date) 格式化日期并返回字符串 Date parse(String source) 指定格式字符串转换为Date对象 exp： import java.text.ParseException; import java.text.SimpleDateFormat; import java.util.Date; public class Main { public static void main(String[] args) { Date date = new Date(); System.out.println(date.toString()); SimpleDateFormat formater = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"); System.out.println(formater.format(date)); try { date = formater.parse(\"2021-12-14 21:16:30\"); System.out.println(date.toString()); } catch (ParseException e) {} } } 运行结果： Tue Dec 14 21:17:47 CST 2021 2021-12-14 21:17:47 Tue Dec 14 21:16:30 CST 2021 import java.text.ParseException; import java.text.SimpleDateFormat; import java.util.Calendar; import java.util.Date; public class Main { public static void main(String[] args) { Calendar calendar = Calendar.getInstance(); Date date = new Date(); System.out.println(date.toString()); calendar.setTime(date); int month = calendar.get(Calendar.MONTH); System.out.println(month);//月份从0开始 calendar.set(Calendar.MONTH,4); System.out.println(calendar.getTime()); } } 运行结果： Tue Dec 14 21:20:48 CST 2021 11 Fri May 14 21:20:48 CST 2021 集合类特点空间自主调整，提高空间利用率，动态存储多个对象。 提供不同的数据结构和算法，减少编程工作量。 提高程序的处理速度和质量。 注意：1.集合类支持引用类型，包括包装类。 2.集合类中存放的是对象的引用，而不是对象本身。 集合类均采用泛型进行定义，分为 Collection 和 Map 两种体系 泛型泛型允许类的成员的类型可以由外部程序来指定，也就是说可以以参数形式来指定类型，即“参数化类型”。常用泛型有泛型接口、泛型类、泛型方法。 泛型类定义class 泛型类名&lt;类型参数表列&gt;{//类体} public class ArrayList&lt;E&gt; { } 泛型接口定义interface 接口名&lt;类型参数表列&gt;{} public interface List&lt;E&gt;{ } 泛型方法定义[&lt;泛型参数&gt;] 方法类型 方法名([泛型参数]){} public boolean add(E e){ } Collection接口List：元素有序，可重复的集合 Set：元素无序、不可重复的集合 Collection 接口是 List、Set 接口的父接口，该接口里定义的方法既可用于操作 Set 集合，也可用于操作 List 集合。 Collection接口方法 类型 方法名 功能 void clear() 删除当前集合中的所有元素 boolean contains(Object o) 查找当前集合中是否有指定元素 boolean containsAll(Collection c) 查找当前集合中是否包含指定集合中的所有元素 boolean isEmpty() 当前集合是否为空 int size() 返回当前集合的元素个数 Iterator iterator() 返回一个可遍历当前集合的迭代器 Object[] toArray() 返回一个当前集合所有元素的数组 boolean add(E e) 向集合中添加新元素 boolean addAll(Collection c) 将指定集合中的所有元素添加到当前集合中 boolean remove(Object o) 删除当前集合中包含的指定元素 boolean removeAll(Collection c) 删除当前集合中与指定集合相同的所有元素 boolean retainAll(Collection c) 保留当前集合中与指定集合相同的所有元素 Map接口具有映射关系“key-value对”的集合 List集合List接口List集合接口，也称之为线性表，是一个有序列表。 集合中的元素是顺序存储，可以通过下标访问。 List集合中允许出现重复元素。 实现List集合接口的常用类：ArrayList、LinkedList、Vector和Stack 主要方法 类型 方法名 功能 boolean add(E e) 把元素e加到表的尾部 void add(int index,E e) 把元素e加到表的index位置，原位置元素后移 boolean equals(Object obj) 比较对象o是否与表中的元素是同一元素 E get(int index) 得到表中index位置的元素 int indexOf(Object o) 判断元素o是否存在，若不则返回-1 Iteratot iterator() 获得表的遍历器 E set(int index,E e) 修改位置上的元素 ArrayList集合类使用数组方式实现List接口 检索效率很高 删除效率很低 即数据结构的顺序表 主要方法 类型 方法名 功能 ArrayList() 构造一个初始容量为10的空列表 ArrayList(Collection c) 构造一个包含指定collectiong的元素列表 ArrayList(int capacity) 构造一个具有指定初始容量的空列表 Boolean add(E e) 把元素e加到表的尾部 E get(int index) 得到表中index位置的元素 boolean indexOf(Object o) 判断元素o是否存在，若不则返回-1 Iterator iterator 获得表的遍历器 import java.util.ArrayList; import java.util.Scanner; public class Main { public static void main(String[] args) { ArrayList&lt;Integer&gt; list =new ArrayList&lt;Integer&gt;(); list.add(1); list.add(3); list.add(5); list.add(7); for (int i=0;i&lt;list.size();i++){ System.out.print(list.get(i)+\",\"); } System.out.println(); list.remove(0); System.out.println(\"The second item = \" + list.get(1)); } } 运行结果： 1，3，5，7 The seconditem = 5 LinkedList集合类使用双向链表方式实现List接口，以及队列Deque接口 删除效率很高 检索效率很低 表示线性序列表，也可以表示堆栈使用，还可以当做队列使用。 主要方法 类型 方法名 功能 LinkedList() 构造一个初始容量为 10 的空列表 LinkedList(Collection c) 构造一个包含指定 collection 的元素的列表 void aa(int index,E element) 把元素e插入到列表index所指位置，并依次后移 boolean add(E e) 把元素e加到表的尾部 boolean indexOf(Object o) 判断元素o在表中是否存在。若不存在，则返回-1 void addFirst(E e) 将元素e插入到列表的头部 E getFirst() 返回列表的头部元素 E removeFirst 从列表中删除头部元素并返回该元素 E pop() 栈顶元素出栈 void push(E e) 元素e入栈 import java.util.ArrayList; import java.util.LinkedList; import java.util.Scanner; public class Main { public static void main(String[] args) { LinkedList&lt;String&gt; list = new LinkedList&lt;String&gt;(); list.add(\"A\"); list.add(\"B\"); list.add(\"C\"); list.add(\"D\"); list.remove(\"C\"); list.addFirst(\"E\"); for(String s : list) { System.out.println(s); }//foreach遍历 } } 运行结果： E A B D Vector集合类是一种动态数组，元素只能是对象 对象类型可以不同 与ArrayList、LinkedList相比，线程安全 通过synchronized关键字修饰方法，实现线程安全 类型 方法名 功能 Vector() 构造一个初始容量为 10 的空列表 Vector(Collection c) 构造一个包含指定 collection 的元素的列表 boolean add(E e) 把元素e加到表的尾部 int indexOf(Object o) 判断元素o在表中是否存在。若不存在，则返回-1 synchronized void addElement(E obj) 将元素e同步插入到列表的尾部 synchronized void removeElement(Object obj) 同步删除元素obj synchronized void insertElementAt(E obj,int index) 在index位置同步插入元素obj synchronized void firstElement() 同步返回第一个元素 import java.util.ArrayList; import java.util.LinkedList; import java.util.Scanner; import java.util.Vector; public class Main { public static void main(String[] args) { Vector v = new Vector(); v.add(\"Hello\"); v.add(\"JDK\"); v.addElement(8.0); for(int i = 0; i &lt; v.size();i++){ System.out.println(v.get(i)); } } } 运行结果： Hello JDK 8.0 Set集合Set集合中元素无序，不重复 方法与Collection相同 实现Set集合接口的类：HashSet、TreeSet 主要方法 HashSet集合类集合中元素无序 元素不重复 元素值可以为空（null） 存储每个元素时会生成一个唯一的整数标识——散列码（hash code），HashSet根据散列码来决定元素所在的存储位置 主要方法 import java.util.HashSet; import java.util.Iterator; public class Main { public static void main(String[] args) { HashSet&lt;String&gt; set = new HashSet&lt;String&gt;(); set.add(\"one\"); set.add(\"two\"); set.add(\"tree\"); set.add(\"one\");//set中存放one,two,three,且无序不重复 System.out.println(set.size()); Iterator&lt;String&gt; iterator = set.iterator(); while(iterator.hasNext()){ System.out.println(iterator.next()); } } } 运行结果： 3 one tree two TreeSet集合类集合中元素有序：采用二叉搜索树的数据结构进行元素的存储，按照树形层次排列，会按其存放的数据的“大小”顺序一层一层地依次排列 元素不重复 存储的元素类型必须是可排序的 主要方法 import java.util.Iterator; import java.util.TreeSet; public class Main { public static void main(String[] args) { TreeSet&lt;String&gt; treeSet = new TreeSet&lt;String&gt;(); treeSet.add(\"banana\"); treeSet.add(\"peach\"); treeSet.add(\"pineapple\"); treeSet.add(\"apple\"); System.out.println(treeSet.first()); System.out.println(treeSet.last()); Iterator&lt;String&gt; iterator = treeSet.iterator(); while(iterator.hasNext()){ System.out.println(iterator.next()); } } } 运行结果： apple pineapple apple banana peach pineapple Map集合用于存放一组成对的“键值对”对象 每个元素包括两部分：键（key）、值（value） 键（key）不能重复，值（value）可以重复 实现Set集合接口的类：HashMap、HashTree、HashTable 主要方法 HashMap集合类采用散列表数据结构存储数据 key-value存储 键（key）不能重复，值（value）可以重复 主要方法 包装类 系统类 其他常用类","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://wenlwei.cn/tags/java/"}]}],"categories":[],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://wenlwei.cn/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"java","slug":"java","permalink":"https://wenlwei.cn/tags/java/"}]}
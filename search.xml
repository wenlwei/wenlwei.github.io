<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/posts/0.html"/>
      <url>/posts/0.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h1><h2 id="查询数据库"><a href="#查询数据库" class="headerlink" title="查询数据库"></a>查询数据库</h2><pre class="line-numbers language-none"><code class="language-none">show datebases;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h2><pre class="line-numbers language-none"><code class="language-none">#直接创建数据库create datebase 数据库1;#判断创建，如果不存在数据库2就创建create datebase if not exists 数据库2;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h2><pre class="line-numbers language-none"><code class="language-none">drop datebase 数据库1;drop datebase if exists 数据库1;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="查看当前正在使用的数据库"><a href="#查看当前正在使用的数据库" class="headerlink" title="查看当前正在使用的数据库"></a>查看当前正在使用的数据库</h2><pre class="line-numbers language-none"><code class="language-none">select datebase();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="使用数据库"><a href="#使用数据库" class="headerlink" title="使用数据库"></a>使用数据库</h2><pre class="line-numbers language-none"><code class="language-none">use 数据库1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="数据库表操作"><a href="#数据库表操作" class="headerlink" title="数据库表操作"></a>数据库表操作</h1><h2 id="查询表"><a href="#查询表" class="headerlink" title="查询表"></a>查询表</h2><pre class="line-numbers language-none"><code class="language-none"># 查询所有表show tables;# 查看表结构desc 表名<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h2><pre class="line-numbers language-none"><code class="language-none">create table(    字段名 数据类型,    字段名 数据类型,    ...    字段名 数据类型);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p><a href="https://imgse.com/i/ppizx1K"><img src="https://s1.ax1x.com/2023/03/02/ppizx1K.png" alt="H9yBpn.png"></a></p><h2 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h2><pre class="line-numbers language-none"><code class="language-none">drop table 表名;drop table if exists 表名<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="修改表"><a href="#修改表" class="headerlink" title="修改表"></a>修改表</h2><pre class="line-numbers language-none"><code class="language-none">#修改表名alter table 表名 rename to 新表名;#添加一列alter table 表名 add 列名 数据类型;#修改数据类型alter table 表名 modify 列名 新数据类型;#修改类名数据类型alter table 表名 change 列名 新列名 新数据类型;#删除列alter table 表名 drop 列名;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="数据库数据操作"><a href="#数据库数据操作" class="headerlink" title="数据库数据操作"></a>数据库数据操作</h1><h2 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h2><pre class="line-numbers language-none"><code class="language-none">#指定列添加数据insert into 表名(列1,列2,...) valuse(值1,值2,...);#给全部列添加数据insert into 表名 valuse(值1,值2,...);#批量添加数据insert into 表名(列1,列2,...) values(值1,值2,...),(值1,值2,...),(值1,值2,...)...;insert into 表名 values(值1,值2,...),(值1,值2,...),(值1,值2,...)...;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="修改表数据"><a href="#修改表数据" class="headerlink" title="修改表数据"></a>修改表数据</h2><pre class="line-numbers language-none"><code class="language-none">update 表名 set 列1=值1,列2=值2,...[where 条件];# 不加条件将修改全部<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h2><pre class="line-numbers language-none"><code class="language-none">delete from 表名 [where 条件]# 不加条件将删除全部<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h1 id="数据库查询操作"><a href="#数据库查询操作" class="headerlink" title="数据库查询操作"></a>数据库查询操作</h1><h2 id="查询多个字段"><a href="#查询多个字段" class="headerlink" title="查询多个字段"></a>查询多个字段</h2><pre class="line-numbers language-none"><code class="language-none">select 字段列表 from 表名;select * from 表名;-- 查询所有数据<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="去除重复记录"><a href="#去除重复记录" class="headerlink" title="去除重复记录"></a>去除重复记录</h2><pre class="line-numbers language-none"><code class="language-none">select distinct 字段列表 from 表名;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="起别名"><a href="#起别名" class="headerlink" title="起别名"></a>起别名</h2><pre class="line-numbers language-none"><code class="language-none">#as[as可以省略]select name,math [as] 数学成绩,english from 表名;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h2><pre class="line-numbers language-none"><code class="language-none">select * from 表名 where 条件;#查询年龄15到20之间的人select name from 表名 where age between 15 and 20;#查询年龄15或20的人select name from 表名 where age = 15 or age = 20;select name from 表名 where age in(18,20);#查询成绩为null的人select name from 表名 grade is null;#查询成绩不为null的人select name from 表名 grade is not null;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://imgse.com/i/ppizz6O"><img src="https://s1.ax1x.com/2023/03/02/ppizz6O.png"></a></p><h2 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h2><p>通配符：</p><p><strong>_</strong>:$\textcolor{red}{代表单个任意字符}$</p><p><strong>%</strong>:$\textcolor{red}{代表任意个数的字符}$</p><pre class="line-numbers language-none"><code class="language-none">#查询姓w的人select * from 表名 where name like 'w%';;#查询第二个字是w的人select * from 表名 where name like '_w%';#查询名字包含w的人select * from 表名 where name likr '%w%';<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="排序查询"><a href="#排序查询" class="headerlink" title="排序查询"></a>排序查询</h2><pre class="line-numbers language-none"><code class="language-none">select 字段列表 from 表名 order by 排序字段名1 [排序方式1],排序字段名2 [排序方式2]...;# 按年龄升序排列select * from 表名 order by age;select * from 表名 order by age asc;# 按成绩排列如果成绩一样则按年龄升序排列select * from 表名 order by grade desc,age asc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>排序方式：ASC升序（默认方式）</p><p>​           DESC：降序</p><p>$\textcolor{red}{如果有多个排序条件，当前面条件值一样时，才会按照第二天排序}$</p><h2 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h2><p>聚合函数：将一列数据作为一个整体，进行纵向计算</p><pre class="line-numbers language-none"><code class="language-none">select 聚合函数(列名) from 表名;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><a href="https://imgse.com/i/ppizvp6"><img src="https://s1.ax1x.com/2023/03/02/ppizvp6.png"></a></p><p>$\textcolor{red}{null值不参与所有聚合函数函数运算}$</p><h2 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h2><pre class="line-numbers language-none"><code class="language-none">select 字段列表 from 表名 [where 分组前条件限定] group by 分组字段名 [having 分组后条件过滤]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>$\textcolor{red}{分组之后，查询的字段为聚合函数和分组字段，查询其他字段无意义}$</p><p>$\textcolor{red}{where和having的区别：}$ 执行时机不一样，where分组前，having分组后</p><p>​                        判断条件不同，having可以对聚会函数判断，where不可以</p><p>执行顺序：where&gt;聚合函数&gt;having</p><h2 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h2><pre class="line-numbers language-none"><code class="language-none">select 字段列表 from 表名 limit 起始索引,查询条目数;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>起始索引(从0开始)=(当前页码-1)*每页显示的条数</p><h1 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h1><p>可以在$\textcolor{red}{建表时添加约束，也可以建表后添加}$</p><p>==建表后==</p><pre class="line-numbers language-none"><code class="language-none"># 非空和唯一约束alter table 表名 modify 字段名 数据类型 关键字# 主键约束alter table 表名 add primary key(字段名)# 默认约束alter table 表名 alter 列名 set default 默认值# 检查约束alter table 表名 add constraint 检查约束名· check(检查约束)# 外键约束alter table 表名 add constraint 外键名称 foreign key (外键字段名称) references 主表名称(主表列名称)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>==删除约束==</p><pre class="line-numbers language-none"><code class="language-none"># 非空约束alter table 表名 modify 字段名 数据类型# 唯一约束alter table 表名 modify drop index 字段名# 主键约束alter table 表名 drop primary key# 默认约束alter table 表名 alter 列名 drop default#检查约束alter table 表名 drop constraint 检查约束名# 外键约束alter table 表名 drop foreign key 外键名称<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="非空约束"><a href="#非空约束" class="headerlink" title="非空约束"></a>非空约束</h2><p>关键字：NOT NULL</p><pre class="line-numbers language-none"><code class="language-none">create table stu(int age not null, #非空)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="唯一约束"><a href="#唯一约束" class="headerlink" title="唯一约束"></a>唯一约束</h2><p>关键字：UNIQUE</p><pre class="line-numbers language-none"><code class="language-none">create table stu(age int not null, # 非空name varchar(50) not null unique, # 非空且唯一)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="主键约束"><a href="#主键约束" class="headerlink" title="主键约束"></a>主键约束</h2><p>关键字：PRIMARY KEY</p><pre class="line-numbers language-none"><code class="language-none">create table stu(id int primary key auto_increment,# 主键且自增长age int not null, # 非空name varchar(50) not null unique, # 非空且唯一)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="检查约束"><a href="#检查约束" class="headerlink" title="检查约束"></a>检查约束</h2><p>关键字：CHECK</p><pre class="line-numbers language-none"><code class="language-none">create table stu(id int primary key auto_increment,# 主键且自增长age int not null, # 非空name varchar(50) not null unique, # 非空且唯一check(age &gt; 18 and age &lt; 60),)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="默认约束"><a href="#默认约束" class="headerlink" title="默认约束"></a>默认约束</h2><p>关键字：DEFAULT</p><pre class="line-numbers language-none"><code class="language-none">create table stu(id int primary key,# 主键且自增长age int not null, # 非空name varchar(50) not null unique, # 非空且唯一bonus double(7,2) default 0 # 没有默认为0)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h2><p>关键字：FOREIGN KEY    </p><pre class="line-numbers language-none"><code class="language-none">create table stu(id int primary key,# 主键且自增长age int not null, # 非空name varchar(50) not null unique, # 非空且唯一bonus double(7,2) default 0 # 没有默认为0teache varchar(50)constraint 外键名称 foreign key(外键列名) refernnces 主表(主表列名))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>两个表之间建立连接</p><h1 id="表关系"><a href="#表关系" class="headerlink" title="表关系"></a>表关系</h1><h2 id="一对多"><a href="#一对多" class="headerlink" title="一对多"></a>一对多</h2><p>一个部门对应多个员工</p><p>$\textcolor{red}{在多的一方建立外表，指向一的一方主键}$</p><h2 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h2><p>商品与订单</p><p>$\textcolor{red}{建立第三张中间表，中间表至少包含两个外键，分别关联两方主键}$</p><h2 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h2><p>用户和用户详情</p><p>多用于表的拆分，将一个实体中经常使用的字段放一张表，不常用的字段放一张表</p><p>$\textcolor{red}{在任意一方加入外键，关联另一方的主键，并且外键唯一}$</p><h1 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h1><pre class="line-numbers language-none"><code class="language-none">select * from 表1, 表2; -- 缺点会产生笛卡尔积：有A，B两个集合，去A，B所有组合情况# 消除无效数据select * from 表1, 表2 where 条件; -- 连接查询# 内连接：查询A，B的交集/*外连接：  左外连接：相当于查询A表所有数据和交集部分数据  右外连接：相当于查询B表所有数据和交集部分数据*/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="内-amp-外连接"><a href="#内-amp-外连接" class="headerlink" title="内&amp;外连接"></a>内&amp;外连接</h2><pre class="line-numbers language-none"><code class="language-none"># 隐式内连接select 字段列表 from 表1, 表2... where 条件# 显示内连接select 字段列表 from 表1 [inner] join 表2 on 条件# 左外连接select 字段列表 from 表1 LEFT [outer] join 表2 on 条件# 右外连接select 字段列表 from 表1 right [outer] join 表2 on 条件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="子查询（嵌套查询）"><a href="#子查询（嵌套查询）" class="headerlink" title="子查询（嵌套查询）"></a>子查询（嵌套查询）</h2><pre class="line-numbers language-none"><code class="language-none"># 单行单列：使用=!=&gt;&lt;等进行条件判断select 字段列表 from 表 where 字段名 = (select ...);# 多行多列：使用in关键字进行条件判断select 字段列表 from 表 where 字段名 in (子查询(select ...));# 多行多列：作为虚拟表select 字段列表 from (子查询) where 条件;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>一种机制，一个操作序列，包含一组操作数据库指令</p><p>同时成功，同时失败</p><p>不可分开的工作逻辑单元</p><pre class="line-numbers language-none"><code class="language-none"># 开启事务start transaction或者begin# 提交事务commit# 回滚事务（出异常时）rollback<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>$\textcolor{red}{事务四大特征}$:</p><pre><code>           1. 原子性：最小操作单位，同时成功同时失败        2. 一致性：事务完成时，所有数据都保持一致状态        3. 隔离性：多个事务之间，操作的可见性        4. 持久性：事务一旦提交或回滚，对数据库中数据的改变是永久的</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>KNN</title>
      <link href="/posts/7c10b52f.html"/>
      <url>/posts/7c10b52f.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="什么是KNN"><a href="#什么是KNN" class="headerlink" title="什么是KNN"></a>什么是KNN</h1><p>K近邻（KNN）算法是一种分类和回归算法，一个未知样本与<strong>数据集</strong>中的K个样本最相似，如果这K个样本中的大多数属于一类，则这未知样本也属于该类</p><p>简单的说就是每个样本都可以用与他最近的K个邻居来代表</p><h1 id="KNN算法"><a href="#KNN算法" class="headerlink" title="KNN算法"></a>KNN算法</h1><hr><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol><li>收集数据</li><li>以所有已知类实例作为参照选择参数K</li><li>计算未知实例与所有已知实例的距离</li><li>选择最近的K个实例（一般取奇数，偶数容易会出现误差）</li><li>判断未知实例属于哪一个类</li></ol><hr><h2 id="判断距离"><a href="#判断距离" class="headerlink" title="判断距离"></a>判断距离</h2><ol><li><a href="https://blog.csdn.net/bluesliuf/article/details/88862918">欧式距离</a></li><li><a href="https://blog.csdn.net/bluesliuf/article/details/88862918">马氏距离</a></li><li><a href="https://blog.csdn.net/qq_39362996/article/details/96896568">曼哈顿距离</a></li></ol><hr><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>优点：精度高，对异常值不敏感，无数据输入假定</p><p>缺点：计算复杂度高，空间复杂度高；在样本分布不平衡时，大样本占主导地位</p><hr><h2 id="Python实现"><a href="#Python实现" class="headerlink" title="Python实现"></a>Python实现</h2><table><thead><tr><th align="center">电影名称</th><th align="center">打斗镜头</th><th align="center">接吻镜头</th><th align="center">电影类型</th></tr></thead><tbody><tr><td align="center">Californian Man</td><td align="center">3</td><td align="center">104</td><td align="center">爱情片</td></tr><tr><td align="center">He’s Not Really into Dudes</td><td align="center">2</td><td align="center">100</td><td align="center">爱情片</td></tr><tr><td align="center">Beautiful Woman</td><td align="center">1</td><td align="center">81</td><td align="center">爱情片</td></tr><tr><td align="center">Kevin Longblade</td><td align="center">101</td><td align="center">10</td><td align="center">动作片</td></tr><tr><td align="center">RobotSlayer 3000</td><td align="center">99</td><td align="center">5</td><td align="center">动作片</td></tr><tr><td align="center">Amped 2</td><td align="center">98</td><td align="center">2</td><td align="center">动作片</td></tr><tr><td align="center">？</td><td align="center">18</td><td align="center">90</td><td align="center">未知</td></tr></tbody></table><p>注：样例来自<a href="https://book.douban.com/subject/24703171/">《机器学习实战》</a> </p><p>先将样例画出散点图很容易判断？属于爱情片</p><pre class="line-numbers language-none"><code class="language-none">"""作者：wenlwei"""import numpy as npimport matplotlib.pyplot as pltimport operator# 爱情篇的打斗镜头x_1 = np.array([3, 2, 1])# 爱情篇的接吻镜头y_1 = np.array([104, 100, 81])# 动作片的打斗镜头x_2 = np.array([101, 99, 98])# 动作片的接吻镜头y_2 = np.array([10, 5, 2])# 未知样例x_3 = np.array([18])y_3 = np.array([90])# 散点图scatter_1 = plt.scatter(x_1, y_1, c = 'g')scatter_2 = plt.scatter(x_2, y_2, c = 'r')scatter_3 = plt.scatter(x_3, y_3, c = 'k')# 画图，标签plt.legend(handles = [scatter_1, scatter_2, scatter_3], labels = ['A', 'B', 'X'], loc = 'best')plt.show()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://s4.ax1x.com/2022/02/28/bKz259.png"></p><p><strong>算法实现</strong></p><pre class="line-numbers language-none"><code class="language-none">"""作者：wenlwei"""import numpy as npimport matplotlib.pyplot as pltimport operator# 已知数据，标签，未知数据x_data = np.array([[3, 104],                  [2, 100],                  [1, 81],                  [101, 10],                  [99, 5],                  [98, 2]])y_label = np.array(['A', 'A', 'A', 'B', 'B', 'B'])x_test = np.array([18, 90])# 已知样本数量x_data_size = x_data.shape[0]# 因为要计算未知样例与所有样例的距离所有需要复制x_test# 行复制x_data_size次，列复制1次diffMat = np.tile(x_test, (x_data_size, 1)) - x_data# 插值的平方sq_diffMat = diffMat**2# 求和sq_sum = sq_diffMat.sum(axis=1)# 开方sqrt_sq_sum = sq_sum**0.5# 按升序排序'''argsort函数返回的是索引例：array = [12, 10, 45, 11, 13]排序后为array = [1, 3, 0, 4, 2]分别对应10，11，12，13，45'''sort_sqrt_sq_sum = sqrt_sq_sum.argsort()# 定义一个空字典，记录标签classCount = {}# 设K=3for i in range(3):    # 获取标签    votelabel = y_label[sort_sqrt_sq_sum[i]]    # 如果不存在就get(0)    classCount[votelabel] = classCount.get(votelabel, 0) + 1# 对classCount排序,True表示倒叙sortedclassCount = sorted(classCount.items(), key=operator.itemgetter(1), reverse=True)# 获取最多的标签判断x_testknn = sortedclassCount[0][0]print(knn)运行结果：A<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>通过结果可以知道knn=A，即？距离k个样例中爱情片最近</strong></p><p>参考文献:</p><p><a href="https://book.douban.com/subject/24703171/">《机器学习实战》</a></p><hr>]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习</title>
      <link href="/posts/498ab7d9.html"/>
      <url>/posts/498ab7d9.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h1><h2 id="机器学习基础"><a href="#机器学习基础" class="headerlink" title="机器学习基础"></a>机器学习基础</h2><p>什么是机器学习？</p><p>通过对信息的统计来利用信息建立模型然后使用模型预测的方法。即将大量的数据转换成有用的信息。</p><p><del>为什么要进行机器学习？</del></p><p>机器学习的<strong>主要任务</strong>：<strong>回归</strong>，<strong>分类</strong></p><p><strong>分类</strong>：将实例数据进行合适分类</p><p><strong>回归</strong>：主要用于预测数值型数据</p><p><strong>训练集</strong>：拥有已大量分类的数据，是用于训练机器学习算法的数据样本集合</p><p><strong>目标变量</strong>：是机器学习算法的预测结果，<strong>分类算法</strong>中目标变量通常是<strong>标称型</strong>，<strong>回归算法</strong>中通常是<strong>连续型</strong></p><p><strong>注意</strong>：<strong>特征或属性</strong>通常是训练样本集的列，是独立测量得到的结果，<strong>多个</strong>特征联系在一起共同组成一个训练样本</p><p><strong>训练数据</strong>：机器学习<strong>开始</strong>时作为算法输入的训练样本集</p><p><strong>测试数据</strong>：训练<strong>完成</strong>后输入的训练样本集</p><p><strong>注</strong>：测试样本时不提供目标变量，由程序决定</p><p>分类和回归都称为<strong>监督学习</strong>，这类算法必须知道要预测什么，即目标变量的分类信息</p><p><strong>无监督学习</strong>即数据没有类别信息，也不给定目标值</p><p><strong>聚类</strong>：无监督学习中，将数据集合分成类似的对象组成的多个类的过程</p><p><strong>密度估计</strong>：寻找描述数据统计值的过程</p><p>无监督学习可以减少数据特征的维度</p><table><thead><tr><th align="center">监督学习的用途</th><th align="center">无监督学习的用途</th></tr></thead><tbody><tr><td align="center">k-近邻算法</td><td align="center">K-均值</td></tr><tr><td align="center">朴素贝叶斯算法</td><td align="center">DBSCAN</td></tr><tr><td align="center">支持向量机</td><td align="center">最大期望算法</td></tr><tr><td align="center">决策树</td><td align="center">Parzem窗设计</td></tr><tr><td align="center">线性回归</td><td align="center"></td></tr><tr><td align="center">局部加权线性回归</td><td align="center"></td></tr><tr><td align="center">Ridge回归</td><td align="center"></td></tr><tr><td align="center">Lasso最小回归系数估计</td><td align="center"></td></tr></tbody></table><hr><h2 id="怎样选择算法"><a href="#怎样选择算法" class="headerlink" title="怎样选择算法"></a>怎样选择算法</h2><p>使用机器学习算法的目的，想要算法完成何种任务</p><p>需要分析或收集的数据是什么</p><p>例如监督学习</p><p><a href="https://imgtu.com/i/HCNOje"><img src="https://s4.ax1x.com/2022/01/30/HCNOje.png" alt="HCNOje.png"></a></p><h1 id="Numpy库基础"><a href="#Numpy库基础" class="headerlink" title="Numpy库基础"></a>Numpy库基础</h1><h2 id="创建随机数组"><a href="#创建随机数组" class="headerlink" title="创建随机数组"></a>创建随机数组</h2><pre class="line-numbers language-none"><code class="language-none">from numpy import *random.rand(4,4)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="创建随机矩阵"><a href="#创建随机矩阵" class="headerlink" title="创建随机矩阵"></a>创建随机矩阵</h2><pre class="line-numbers language-none"><code class="language-none">from numpy import *randMat = mat (random.rand(4,4))randMat<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="逆矩阵"><a href="#逆矩阵" class="headerlink" title="逆矩阵"></a>逆矩阵</h3><pre class="line-numbers language-none"><code class="language-none">randMat.I<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="存储矩阵"><a href="#存储矩阵" class="headerlink" title="存储矩阵"></a>存储矩阵</h2><pre class="line-numbers language-none"><code class="language-none">invRandMat = randMat.I<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="矩阵相乘"><a href="#矩阵相乘" class="headerlink" title="矩阵相乘"></a>矩阵相乘</h2><pre class="line-numbers language-none"><code class="language-none">randMat*invRandMat<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="单位矩阵"><a href="#单位矩阵" class="headerlink" title="单位矩阵"></a>单位矩阵</h2><pre class="line-numbers language-none"><code class="language-none">from numpy import *randMat = mat (random.rand(4,4))randMat.IinvRandMat = randMat.IrandMat*invRandMat# 得误差值myEye = randMat*invRandMatmyEye - eye(4)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="k-近邻算法"><a href="#k-近邻算法" class="headerlink" title="k-近邻算法"></a>k-近邻算法</h1>]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java类</title>
      <link href="/posts/46779f67.html"/>
      <url>/posts/46779f67.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Java类"><a href="#Java类" class="headerlink" title="Java类"></a>Java类</h1><h2 id="字符串类"><a href="#字符串类" class="headerlink" title="字符串类"></a>字符串类</h2><h3 id="字符串处理的类"><a href="#字符串处理的类" class="headerlink" title="字符串处理的类"></a>字符串处理的类</h3><p><strong>String，StringBuffer</strong></p><p><strong>SringTokenizer</strong></p><p><strong>StringBuilder</strong></p><p><strong>StreamTokenozer</strong></p><hr><h3 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h3><p>String类定义的字符串是不可变长的。</p><p>String类是final类，是不可改变的，所以其创建对象的值无法改变。</p><p>String类中提供更改对象内容的方法并未真正更改内容，而是创建一个新的对象并返回。</p><p>字符串常量存储在<strong>常量池</strong>中，且常量唯一</p><p>直接引用字符串常量引用的是常量池中定义的常量，若<strong>无则创建</strong>。</p><p>通过<strong>构造方法</strong>创建，在堆内存中创建变量</p><p>exp： String str =  new String(“Java”);</p><p>exp：String str1=“Java”；</p><p>​       String str2=“Java”；</p><p>str1,str2引用的是同一实体Java</p><p>str1**==<strong>str2比较的是</strong>地址**</p><p>String s1 = new String(“World”);</p><p>String s2 = new String(“World”);</p><p>String s3 = “World”;</p><p>s1、s2分别在堆内存中分别创建一个World实体。</p><p>s1==s2不成立(<strong>地址</strong>)</p><p>s2==s3不成立(<strong>地址</strong>)</p><p>s2.<strong>equals</strong>(s3)成立</p><hr><h3 id="String对象是不可变的"><a href="#String对象是不可变的" class="headerlink" title="String对象是不可变的"></a>String对象是不可变的</h3><p>s1=“Hello”；</p><p>s1=“Hello Java”</p><p>创建了一个新的对象 “Hello Java”，而原来的 “Hello” 还存在于内存中</p><hr><h3 id="String类常用方法"><a href="#String类常用方法" class="headerlink" title="String类常用方法"></a>String类常用方法</h3><table><thead><tr><th align="center">返回类型</th><th align="center">方法名</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center"></td><td align="center">Sting()</td><td align="center">创建一个空字符串对象</td></tr><tr><td align="center"></td><td align="center">String(char value)</td><td align="center">用字符数组value创建一个字符串对象</td></tr><tr><td align="center"></td><td align="center">String(String str)</td><td align="center">用字符串对象创建一个心的字符串对象</td></tr><tr><td align="center">char[]</td><td align="center">toCharArray()</td><td align="center">将字符串转化为字符数组</td></tr><tr><td align="center">cahr</td><td align="center">charAt(int i)</td><td align="center">返回指定索引位置的值</td></tr><tr><td align="center">int</td><td align="center">compare To(String str)</td><td align="center">按字典序比较两个字符串</td></tr><tr><td align="center">String</td><td align="center">concat(String str)</td><td align="center">将str连接到当前字符串末尾</td></tr><tr><td align="center">boolean</td><td align="center">contains(CharSequence s)</td><td align="center">此字符串包含char值序列s返回true</td></tr><tr><td align="center">boolean</td><td align="center">equals(Object obj)</td><td align="center">当前字符串与对象比较</td></tr><tr><td align="center">boolean</td><td align="center">isEmpty()</td><td align="center">判断字符串是否为空</td></tr><tr><td align="center">int</td><td align="center">index Of(String str)</td><td align="center">返回当前字符串第一次出现str的索引</td></tr><tr><td align="center">int</td><td align="center">length()</td><td align="center">返回当前字符串的长度</td></tr><tr><td align="center">boolean</td><td align="center">matches(String regex)</td><td align="center">判断当前串是否匹配正则表达式</td></tr><tr><td align="center">String</td><td align="center">replace(char&nbsp;old, char&nbsp;new)</td><td align="center">对字符串中所有字符old替换为new</td></tr><tr><td align="center">Sting[]</td><td align="center">split(String regex)</td><td align="center">按给定正则表达式的匹配拆分字符串</td></tr><tr><td align="center">boolean</td><td align="center">tartsWith(String prefix)</td><td align="center">判断当前串是否以prefix开头</td></tr><tr><td align="center">String</td><td align="center">substring(int&nbsp;begin, int&nbsp;end)</td><td align="center">返回当前字符串的一个子字符串</td></tr><tr><td align="center">String</td><td align="center">trim()</td><td align="center">删除前导空格和尾部空格</td></tr><tr><td align="center">static String</td><td align="center">valueOf(Object obj)</td><td align="center">返回 Object 参数的字符串表示形式</td></tr></tbody></table><pre class="line-numbers language-none"><code class="language-none">String str1 = new String("abc");String str2 = new String("abc");System.out.println(str1 == str2);System.out.println(str1.equals(str2));运行结果：false     true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">String str1 = "hello";String str2 = "java";int result = str1.compareTo(str2);System.out.println(result);运行结果：返回第一个不相等字符的ASCII之差-2 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">String str1 = "how are you!";int x = 97; //a的ASCII值int index = str1.indexOf(x);System.out.println(index);运行结果:4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">String str1 = "end line,end line";String str2 = str1.replace('e', 'a');System.out.println(str2);str2 = str1.replaceAll("end", "start");System.out.println(str3);运行结果：and lina,and linastart line,start line<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">String str1 = "I am a student";String str2 = str1.substring(5);System.out.println(str2);运行结果：a student<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">String str1 = "I am a student";String str2 = str1.substring(2,8);System.out.println(str2);运行结果：am a s   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">String str1 = "hello java world";String[] str2 = str1.split(" ");for(String s : str2){     System.out.println(s);}运行结果：hellojavaworld <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h3><p>StringBuffer类定义的字符串是<strong>变长</strong>的。</p><p>StringBuffer类创建对象的值<strong>允许改变</strong>，用于字符串动态变化。</p><p>常用方法包括字符串尾部追加、插入、内容替换、字符串中删除子串、字符串倒序、返回缓冲区容量等</p><hr><h3 id="StringBuffer类常用方法"><a href="#StringBuffer类常用方法" class="headerlink" title="StringBuffer类常用方法"></a>StringBuffer类常用方法</h3><table><thead><tr><th align="center">返回类型</th><th align="center">方法名</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center"></td><td align="center">StringBuffer()</td><td align="center">构造一个16字符的字符串缓冲区</td></tr><tr><td align="center"></td><td align="center">StringBuffer(int a)</td><td align="center">构造一指定容量的字符串缓冲区</td></tr><tr><td align="center"></td><td align="center">StringBuffer(String str)</td><td align="center">构造一指定串str另加16字符的缓冲区</td></tr><tr><td align="center"></td><td align="center">StringBuffer(CharSequence s)</td><td align="center">构造一字符序列s另加16字符的缓冲区</td></tr><tr><td align="center">String</td><td align="center">toString()</td><td align="center">转换为String字符串</td></tr><tr><td align="center">StringBuffer</td><td align="center">append(String str)</td><td align="center">追加字符串</td></tr><tr><td align="center">StringBuffer</td><td align="center">insert(int offset, String str)</td><td align="center">指定位置插入字符串</td></tr><tr><td align="center">StringBuffer</td><td align="center">reverse()</td><td align="center">字符翻转</td></tr><tr><td align="center">StringBuffer</td><td align="center">delete(int startIndex,int endIndex)</td><td align="center">删除startIndex与endIndex（不包括）之间的字符</td></tr><tr><td align="center">StringBuffer</td><td align="center">replace(int startIndex,int endIndex,String str)</td><td align="center">用str替换startIndex与endIndex（不包括）之间的字符</td></tr></tbody></table><pre class="line-numbers language-none"><code class="language-none">StringBuffer buffer = new StringBuffer();System.out.println(buffer.toString());buffer.append("JDK");//末尾追加buffer.append(8.0);System.out.println(buffer.toString());buffer.insert(0, "Hello ");//指定位置插入System.out.println(buffer.toString());buffer.delete(9, 12);//删除指定位置之间System.out.println(buffer.toString());运行结果：JDK8.0Hello JDK8.0Hello JDK<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">StringBuffer buffer = new StringBuffer("Hello Java!");System.out.println(buffer.toString());buffer.replace(6, 11, "Python");//替换System.out.println(buffer.toString());buffer.reverse();//翻转System.out.println(buffer.toString());运行结果：Hello Java!Hello PythonnohtyP olleH<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h3><p>StringBuilder和StringBuffer方法类似。</p><p>StringBuffer 的方法是<strong>线程安全</strong>的（不能同步访问），而StringBuilder不是。</p><hr><h3 id="String与StringBuffer比较"><a href="#String与StringBuffer比较" class="headerlink" title="String与StringBuffer比较"></a>String与StringBuffer比较</h3><h4 id="构造方法不同"><a href="#构造方法不同" class="headerlink" title="构造方法不同"></a>构造方法不同</h4><p><strong>String创建的字符串是常量，创建后不能改变</strong>；</p><p><strong>StringBuffer创建的是缓冲区，其字符串可以改变</strong>。</p><h4 id="成员方法不同"><a href="#成员方法不同" class="headerlink" title="成员方法不同"></a>成员方法不同</h4><p>String类的成员方法以只读数据为主；</p><p>StringBuffer的成员方法则可以读写字符串。</p><hr><h3 id="StringTokenizer类"><a href="#StringTokenizer类" class="headerlink" title="StringTokenizer类"></a>StringTokenizer类</h3><p>用于字符串分割，同时支持多种分隔符。</p><p>属于java.util包</p><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><p>StringTokenizer（String s），分隔标记默认为空格</p><p>StringTokenizer（String s, String delim），delim中的字符的任意排列组合都是分隔标记</p><p>public int countTokens()；// 分割串的个数</p><p>public boolean hasMoreTokens()；// 是否还有分割串</p><p>public String nextToken()；// 得到下一分割串</p><p>exp：</p><pre class="line-numbers language-none"><code class="language-none">import java.util.StringTokenizer;public class Main {public static void main(String[] args)  {        String s = "I am Jame  ,,,  you are Jerry,and he is Tom";        StringTokenizer tokenizer= new StringTokenizer(s," ,");//空格、逗号        int number = tokenizer.countTokens();// 获取单词总数        while (tokenizer.hasMoreTokens()){// 是否还有单词        String str = tokenizer.nextToken();// 获得下一个单词        System.out.println(str);        }        System.out.println("总共单词数：" + number);    } }运行结果：IamJameyouareJerryandheisTom总共单词数：10<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="数学类"><a href="#数学类" class="headerlink" title="数学类"></a>数学类</h2><p>Math（数学类）</p><p>Random（随机数类）</p><hr><h3 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h3><p>用于数学计算</p><p>Math类的所有属性和方法都是静态的</p><p>常用方法：取绝对值abs()、求最大值max()、求最小值min()、产生随机数random()、乘幂pow()、平方根sqrt()、对数log()、三角函数运算。</p><hr><h3 id="Random"><a href="#Random" class="headerlink" title="Random"></a>Random</h3><p>用于产生随机数</p><p>常用方法：支持基本类型随机数的产生。包括nextBoolean()、nextBytes()、nextDouble()、nextInt()、nextInt(int n)、nextLong()、setSeed()等。</p><p>exp：</p><pre class="line-numbers language-none"><code class="language-none">import java.util.Random;public class Main {public static void main(String[] args)  {Random r = new Random();int number = r.nextInt(10);System.out.println(number);    } }运行结果：7<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="Date类"><a href="#Date类" class="headerlink" title="Date类"></a>Date类</h2><p>Date类在包java.util</p><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><table><thead><tr><th align="center">返回类型</th><th align="center">方法名</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center"></td><td align="center">Date()</td><td align="center">构造方法，获取系统日期</td></tr><tr><td align="center">boolean</td><td align="center">after(Date d)</td><td align="center">测试此日期是否在指定日期之后</td></tr><tr><td align="center">boolean</td><td align="center">before(Date d)</td><td align="center">测试此日期是否在指定日期之前</td></tr><tr><td align="center">int</td><td align="center">compareTo(Date d)</td><td align="center">比较两个日期的顺序</td></tr><tr><td align="center">long</td><td align="center">getTime()</td><td align="center">返回自格林尼治GMT1970年1月1日00:00:00以来此 Date 对象表示的毫秒数</td></tr></tbody></table><hr><h2 id="Calendar类"><a href="#Calendar类" class="headerlink" title="Calendar类"></a>Calendar类</h2><p>日历类Calendar定义在java.util包</p><h3 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h3><table><thead><tr><th align="center">返回类型</th><th align="center">方法名</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">int</td><td align="center">get(int field)</td><td align="center">返回给定日历字段的值</td></tr><tr><td align="center">Date</td><td align="center">getTime()</td><td align="center">返回一个表示此Calemder时间值的Date对象</td></tr><tr><td align="center">long</td><td align="center">getTimeInMillis()</td><td align="center">返回以毫秒为单位的此日历的时间值</td></tr><tr><td align="center">void</td><td align="center">set(int field,int value)</td><td align="center">将给定的日历字段设置为给定值</td></tr><tr><td align="center">void</td><td align="center">setTime(Date date)</td><td align="center">使用给定的Date实例设置此Calender对象的时间</td></tr></tbody></table><hr><h2 id="日期格式化"><a href="#日期格式化" class="headerlink" title="日期格式化"></a>日期格式化</h2><p>格式化日期SimpleDateFormat类在包java.text</p><h3 id="常用方法-2"><a href="#常用方法-2" class="headerlink" title="常用方法"></a>常用方法</h3><table><thead><tr><th align="center">返回类型</th><th align="center">方法名</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center"></td><td align="center">SimpleDateFormat(String pattern)</td><td align="center">构造方法，设置格式化日期格式</td></tr><tr><td align="center">String</td><td align="center">format(Date date)</td><td align="center">格式化日期并返回字符串</td></tr><tr><td align="center">Date</td><td align="center">parse(String source)</td><td align="center">指定格式字符串转换为Date对象</td></tr></tbody></table><hr><p>exp：</p><pre class="line-numbers language-none"><code class="language-none">import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;public class Main {public static void main(String[] args)  {Date date = new Date();System.out.println(date.toString());SimpleDateFormat formater = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");System.out.println(formater.format(date));try {    date = formater.parse("2021-12-14 21:16:30");   System.out.println(date.toString());} catch (ParseException e) {}    } }运行结果：Tue Dec 14 21:17:47 CST 20212021-12-14 21:17:47Tue Dec 14 21:16:30 CST 2021<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Calendar;import java.util.Date;public class Main {public static void main(String[] args)  {Calendar calendar = Calendar.getInstance();Date date = new Date();System.out.println(date.toString());calendar.setTime(date);int month = calendar.get(Calendar.MONTH);System.out.println(month);//月份从0开始  calendar.set(Calendar.MONTH,4);System.out.println(calendar.getTime());    } }运行结果：Tue Dec 14 21:20:48 CST 202111Fri May 14 21:20:48 CST 2021<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="集合类"><a href="#集合类" class="headerlink" title="集合类"></a>集合类</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>空间自主调整，提高空间利用率，动态存储多个对象。</p><p>提供不同的数据结构和算法，减少编程工作量。</p><p>提高程序的处理速度和质量。</p><p><strong>注意</strong>：1.集合类支持引用类型，包括包装类。</p><p>2.集合类中存放的是对象的引用，而不是对象本身。</p><hr><p>集合类均采用<strong>泛型</strong>进行定义，分为 Collection 和 Map 两种体系</p><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>泛型允许类的成员的类型可以由外部程序来指定，也就是说可以以参数形式来指定类型，即“参数化类型”。常用泛型有泛型接口、泛型类、泛型方法。</p><h4 id="泛型类定义"><a href="#泛型类定义" class="headerlink" title="泛型类定义"></a>泛型类定义</h4><p>class 泛型类名&lt;类型参数表列&gt;{//类体}</p><pre class="line-numbers language-none"><code class="language-none">public class ArrayList&lt;E&gt; { } <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="泛型接口定义"><a href="#泛型接口定义" class="headerlink" title="泛型接口定义"></a>泛型接口定义</h4><p>interface 接口名&lt;类型参数表列&gt;{}</p><pre class="line-numbers language-none"><code class="language-none">public interface List&lt;E&gt;{ }<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="泛型方法定义"><a href="#泛型方法定义" class="headerlink" title="泛型方法定义"></a>泛型方法定义</h4><p>[&lt;泛型参数&gt;] 方法类型 方法名([泛型参数]){}</p><pre class="line-numbers language-none"><code class="language-none">public boolean add(E e){ }<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><h3 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h3><p>List：元素<strong>有序</strong>，<strong>可重复</strong>的集合</p><p>Set：元素<strong>无序</strong>、<strong>不可重复</strong>的集合</p><p>Collection 接口是 List、Set 接口的父接口，该接口里定义的方法既可用于操作 Set 集合，也可用于操作 List 集合。</p><h4 id="Collection接口方法"><a href="#Collection接口方法" class="headerlink" title="Collection接口方法"></a>Collection接口方法</h4><table><thead><tr><th align="center">类型</th><th align="center">方法名</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">void</td><td align="center">clear()</td><td align="center">删除当前集合中的所有元素</td></tr><tr><td align="center">boolean</td><td align="center">contains(Object o)</td><td align="center">查找当前集合中是否有指定元素</td></tr><tr><td align="center">boolean</td><td align="center">containsAll(Collection c)</td><td align="center">查找当前集合中是否包含指定集合中的所有元素</td></tr><tr><td align="center">boolean</td><td align="center">isEmpty()</td><td align="center">当前集合是否为空</td></tr><tr><td align="center">int</td><td align="center">size()</td><td align="center">返回当前集合的元素个数</td></tr><tr><td align="center">Iterator</td><td align="center">iterator()</td><td align="center">返回一个可遍历当前集合的迭代器</td></tr><tr><td align="center">Object[]</td><td align="center">toArray()</td><td align="center">返回一个当前集合所有元素的数组</td></tr><tr><td align="center">boolean</td><td align="center">add(E e)</td><td align="center">向集合中添加新元素</td></tr><tr><td align="center">boolean</td><td align="center">addAll(Collection c)</td><td align="center">将指定集合中的所有元素添加到当前集合中</td></tr><tr><td align="center">boolean</td><td align="center">remove(Object o)</td><td align="center">删除当前集合中包含的指定元素</td></tr><tr><td align="center">boolean</td><td align="center">removeAll(Collection c)</td><td align="center">删除当前集合中与指定集合相同的所有元素</td></tr><tr><td align="center">boolean</td><td align="center">retainAll(Collection c)</td><td align="center">保留当前集合中与指定集合相同的所有元素</td></tr></tbody></table><h3 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h3><p>具有映射关系“key-value对”的集合</p><hr><h2 id="List集合"><a href="#List集合" class="headerlink" title="List集合"></a>List集合</h2><h4 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h4><p>List集合接口，也称之为线性表，是一个<strong>有序列表</strong>。</p><p>集合中的元素是顺序存储，可以通过下标访问。</p><p>List集合中<strong>允许出现重复元素</strong>。</p><p>实现List集合接口的常用类：ArrayList、LinkedList、Vector和Stack</p><h4 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h4><table><thead><tr><th align="center">类型</th><th align="center">方法名</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">boolean</td><td align="center">add(E e)</td><td align="center">把元素e加到表的尾部</td></tr><tr><td align="center">void</td><td align="center">add(int index,E e)</td><td align="center">把元素e加到表的index位置，原位置元素后移</td></tr><tr><td align="center">boolean</td><td align="center">equals(Object obj)</td><td align="center">比较对象o是否与表中的元素是同一元素</td></tr><tr><td align="center">E</td><td align="center">get(int index)</td><td align="center">得到表中index位置的元素</td></tr><tr><td align="center">int</td><td align="center">indexOf(Object o)</td><td align="center">判断元素o是否存在，若不则返回-1</td></tr><tr><td align="center">Iteratot<e></e></td><td align="center">iterator()</td><td align="center">获得表的遍历器</td></tr><tr><td align="center">E</td><td align="center">set(int index,E e)</td><td align="center">修改位置上的元素</td></tr></tbody></table><h3 id="ArrayList集合类"><a href="#ArrayList集合类" class="headerlink" title="ArrayList集合类"></a>ArrayList集合类</h3><p>使用数组方式实现List接口</p><p>检索效率很高</p><p>删除效率很低</p><p>即数据结构的顺序表</p><h4 id="主要方法-1"><a href="#主要方法-1" class="headerlink" title="主要方法"></a>主要方法</h4><table><thead><tr><th align="center">类型</th><th align="center">方法名</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center"></td><td align="center">ArrayList()</td><td align="center">构造一个初始容量为10的空列表</td></tr><tr><td align="center"></td><td align="center">ArrayList(Collection c)</td><td align="center">构造一个包含指定collectiong的元素列表</td></tr><tr><td align="center"></td><td align="center">ArrayList(int capacity)</td><td align="center">构造一个具有指定初始容量的空列表</td></tr><tr><td align="center">Boolean</td><td align="center">add(E e)</td><td align="center">把元素e加到表的尾部</td></tr><tr><td align="center">E</td><td align="center">get(int index)</td><td align="center">得到表中index位置的元素</td></tr><tr><td align="center">boolean</td><td align="center">indexOf(Object o)</td><td align="center">判断元素o是否存在，若不则返回-1</td></tr><tr><td align="center">Iterator<e></e></td><td align="center">iterator</td><td align="center">获得表的遍历器</td></tr></tbody></table><pre class="line-numbers language-none"><code class="language-none">import java.util.ArrayList;import java.util.Scanner;public class Main {public static void main(String[] args) {ArrayList&lt;Integer&gt; list =new ArrayList&lt;Integer&gt;();  list.add(1);  list.add(3);  list.add(5);  list.add(7);  for (int i=0;i&lt;list.size();i++){      System.out.print(list.get(i)+",");  }  System.out.println();  list.remove(0);  System.out.println("The second item = " + list.get(1));}}运行结果：1，3，5，7The seconditem = 5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="LinkedList集合类"><a href="#LinkedList集合类" class="headerlink" title="LinkedList集合类"></a>LinkedList集合类</h3><p>使用<strong>双向</strong>链表方式实现List接口，以及队列Deque接口</p><p>删除效率很高</p><p>检索效率很低</p><p>表示线性序列表，也可以表示堆栈使用，还可以当做队列使用。</p><h4 id="主要方法-2"><a href="#主要方法-2" class="headerlink" title="主要方法"></a>主要方法</h4><table><thead><tr><th align="center">类型</th><th align="center">方法名</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center"></td><td align="center">LinkedList()</td><td align="center">构造一个初始容量为 10 的空列表</td></tr><tr><td align="center"></td><td align="center">LinkedList(Collection c)</td><td align="center">构造一个包含指定 collection 的元素的列表</td></tr><tr><td align="center">void</td><td align="center">aa(int index,E element)</td><td align="center">把元素e插入到列表index所指位置，并依次后移</td></tr><tr><td align="center">boolean</td><td align="center">add(E e)</td><td align="center">把元素e加到表的尾部</td></tr><tr><td align="center">boolean</td><td align="center">indexOf(Object o)</td><td align="center">判断元素o在表中是否存在。若不存在，则返回-1</td></tr><tr><td align="center">void</td><td align="center">addFirst(E e)</td><td align="center">将元素e插入到列表的头部</td></tr><tr><td align="center">E</td><td align="center">getFirst()</td><td align="center">返回列表的头部元素</td></tr><tr><td align="center">E</td><td align="center">removeFirst</td><td align="center">从列表中删除头部元素并返回该元素</td></tr><tr><td align="center">E</td><td align="center">pop()</td><td align="center">栈顶元素出栈</td></tr><tr><td align="center">void</td><td align="center">push(E e)</td><td align="center">元素e入栈</td></tr></tbody></table><pre class="line-numbers language-none"><code class="language-none">import java.util.ArrayList;import java.util.LinkedList;import java.util.Scanner;public class Main {public static void main(String[] args) {LinkedList&lt;String&gt; list = new LinkedList&lt;String&gt;();list.add("A");list.add("B");list.add("C");list.add("D");list.remove("C");list.addFirst("E");for(String s : list) {    System.out.println(s); }//foreach遍历}}运行结果：EABD<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="Vector集合类"><a href="#Vector集合类" class="headerlink" title="Vector集合类"></a>Vector集合类</h3><p>是一种<strong>动态</strong>数组，元素只能是对象</p><p>对象类型可以不同</p><p>与ArrayList、LinkedList相比，<strong>线程安全</strong></p><p>通过<strong>synchronized</strong>关键字修饰方法，实现线程安全</p><table><thead><tr><th align="center">类型</th><th align="center">方法名</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center"></td><td align="center">Vector()</td><td align="center">构造一个初始容量为 10 的空列表</td></tr><tr><td align="center"></td><td align="center">Vector(Collection c)</td><td align="center">构造一个包含指定 collection 的元素的列表</td></tr><tr><td align="center">boolean</td><td align="center">add(E e)</td><td align="center">把元素e加到表的尾部</td></tr><tr><td align="center">int</td><td align="center">indexOf(Object o)</td><td align="center">判断元素o在表中是否存在。若不存在，则返回-1</td></tr><tr><td align="center">synchronized void</td><td align="center">addElement(E obj)</td><td align="center">将元素e同步插入到列表的尾部</td></tr><tr><td align="center">synchronized void</td><td align="center">removeElement(Object obj)</td><td align="center">同步删除元素obj</td></tr><tr><td align="center">synchronized void</td><td align="center">insertElementAt(E obj,int index)</td><td align="center">在index位置同步插入元素obj</td></tr><tr><td align="center">synchronized void</td><td align="center">firstElement()</td><td align="center">同步返回第一个元素</td></tr></tbody></table><pre class="line-numbers language-none"><code class="language-none">import java.util.ArrayList;import java.util.LinkedList;import java.util.Scanner;import java.util.Vector;public class Main {public static void main(String[] args) {Vector v = new Vector();v.add("Hello");v.add("JDK");v.addElement(8.0);        for(int i = 0; i &lt; v.size();i++){    System.out.println(v.get(i));}}}运行结果：HelloJDK8.0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="Set集合"><a href="#Set集合" class="headerlink" title="Set集合"></a>Set集合</h2><p>Set集合中元素<strong>无序，不重复</strong></p><p>方法与Collection相同</p><p>实现Set集合接口的类：HashSet、TreeSet</p><hr><h4 id="主要方法-3"><a href="#主要方法-3" class="headerlink" title="主要方法"></a>主要方法</h4><p><a href="https://imgtu.com/i/H9ywfs"><img src="https://s4.ax1x.com/2022/01/30/H9ywfs.png" alt="H9ywfs.png"></a></p><hr><h3 id="HashSet集合类"><a href="#HashSet集合类" class="headerlink" title="HashSet集合类"></a>HashSet集合类</h3><p>集合中元素<strong>无序</strong></p><p>元素<strong>不重复</strong></p><p>元素<strong>值</strong>可以为<strong>空（null）</strong></p><p>存储每个元素时会生成一个唯一的整数标识——<strong>散列码</strong>（hash code），HashSet根据散列码来决定元素所在的存储位置</p><hr><h4 id="主要方法-4"><a href="#主要方法-4" class="headerlink" title="主要方法"></a>主要方法</h4><p><a href="https://imgtu.com/i/H9yBpn"><img src="https://s4.ax1x.com/2022/01/30/H9yBpn.png" alt="H9yBpn.png"></a></p><hr><pre class="line-numbers language-none"><code class="language-none">import java.util.HashSet;import java.util.Iterator;public class Main {public static void main(String[] args) {HashSet&lt;String&gt; set = new HashSet&lt;String&gt;();set.add("one");set.add("two");set.add("tree");set.add("one");//set中存放one,two,three,且无序不重复System.out.println(set.size());Iterator&lt;String&gt; iterator = set.iterator();while(iterator.hasNext()){    System.out.println(iterator.next());}}}运行结果：3onetreetwo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="TreeSet集合类"><a href="#TreeSet集合类" class="headerlink" title="TreeSet集合类"></a>TreeSet集合类</h3><p>集合中元素<strong>有序</strong>：采用<strong>二叉搜索树</strong>的数据结构进行元素的存储，按照树形层次排列，会按其存放的数据的“大小”顺序一层一层地依次排列</p><p>元素<strong>不重复</strong></p><p>存储的元素类型必须是<strong>可排序</strong>的</p><hr><h4 id="主要方法-5"><a href="#主要方法-5" class="headerlink" title="主要方法"></a>主要方法</h4><p><a href="https://imgtu.com/i/H9yfh9"><img src="https://s4.ax1x.com/2022/01/30/H9yfh9.png" alt="H9yfh9.png"></a></p><pre class="line-numbers language-none"><code class="language-none">import java.util.Iterator;import java.util.TreeSet;public class Main {public static void main(String[] args) {TreeSet&lt;String&gt; treeSet = new TreeSet&lt;String&gt;();treeSet.add("banana");treeSet.add("peach");treeSet.add("pineapple");treeSet.add("apple");  System.out.println(treeSet.first());System.out.println(treeSet.last());Iterator&lt;String&gt; iterator = treeSet.iterator();while(iterator.hasNext()){   System.out.println(iterator.next());}}}运行结果：applepineappleapplebananapeachpineapple<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="Map集合"><a href="#Map集合" class="headerlink" title="Map集合"></a>Map集合</h2><p>用于存放一组成对的<strong>“键值对”</strong>对象</p><p>每个元素包括两部分：<strong>键（key）</strong>、<strong>值（value）</strong></p><p><strong>键（key）不能重复</strong>，<strong>值（value）可以重复</strong></p><p>实现Set集合接口的类：HashMap、HashTree、HashTable</p><hr><h4 id="主要方法-6"><a href="#主要方法-6" class="headerlink" title="主要方法"></a>主要方法</h4><p><a href="https://imgtu.com/i/H9yWtJ"><img src="https://s4.ax1x.com/2022/01/30/H9yWtJ.png" alt="H9yWtJ.png"></a></p><p><a href="https://imgtu.com/i/H9yRk4"><img src="https://s4.ax1x.com/2022/01/30/H9yRk4.png" alt="H9yRk4.png"></a></p><hr><h3 id="HashMap集合类"><a href="#HashMap集合类" class="headerlink" title="HashMap集合类"></a>HashMap集合类</h3><p>采用散列表数据结构存储数据</p><p>key-value存储</p><p>键（key）不能重复，值（value）可以重复</p><h4 id="主要方法-7"><a href="#主要方法-7" class="headerlink" title="主要方法"></a>主要方法</h4><p><a href="https://imgtu.com/i/H9yOtH"><img src="https://s4.ax1x.com/2022/01/30/H9yOtH.png" alt="H9yOtH.png"></a></p><h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><hr><h2 id="系统类"><a href="#系统类" class="headerlink" title="系统类"></a>系统类</h2><hr><h2 id="其他常用类"><a href="#其他常用类" class="headerlink" title="其他常用类"></a>其他常用类</h2>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>

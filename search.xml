<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>软件工程</title>
      <link href="/posts/7821ac43.html"/>
      <url>/posts/7821ac43.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>常识出选择判断题</p><h1 id="软件工程概述"><a href="#软件工程概述" class="headerlink" title="软件工程概述"></a>软件工程概述</h1><p>软件发展标志性事件：1960年代IBM宣布软件与硬件解除绑定并对软件单独计价</p><h2 id="怎么理解软件工程："><a href="#怎么理解软件工程：" class="headerlink" title="怎么理解软件工程："></a>怎么理解软件工程：</h2><ol><li>软件开发的工程化或工程化的软件开发</li><li>基本追求：质量、成本、效率</li><li>编程与软件开发的区别：<ol><li>编写的程序没有针对来自现实世界的需求</li><li>不考虑相关的质量要求</li><li>没有按照工程化的过程进行开发</li><li>不考虑长期演化和维护的问题</li></ol></li></ol><h2 id="软件工程特点"><a href="#软件工程特点" class="headerlink" title="软件工程特点"></a>软件工程特点</h2><ol><li>过程标准化</li><li>理论和实践支撑</li><li>质量有保障</li><li>追求实用</li></ol><h2 id="软件工程诞生的直接原因：软件危机"><a href="#软件工程诞生的直接原因：软件危机" class="headerlink" title="软件工程诞生的直接原因：软件危机"></a>软件工程诞生的直接原因：软件危机</h2><p>软件危机：</p><ol><li>软件开发进度难以预测</li><li>软件开发成本难以控制</li><li>用户对产品功能难以满足</li><li>软件产品质量无法保证</li><li>软件产品难以维护</li></ol><h2 id="软件工程的基本关注点"><a href="#软件工程的基本关注点" class="headerlink" title="软件工程的基本关注点"></a>软件工程的基本关注点</h2><p>(创新)</p><pre class="line-numbers language-mermaid" data-language="mermaid"><code class="language-mermaid">graph LR;质量 --&gt;时间;时间 --&gt; 成本;成本 --&gt; 质量;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h1 id="软件过程-计划驱动，敏捷"><a href="#软件过程-计划驱动，敏捷" class="headerlink" title="软件过程:计划驱动，敏捷"></a>软件过程:计划驱动，敏捷</h1><p>软件过程定义了软件组织和人员在软件产品的定义、开发和维护等阶段所实施的一系列活动和任务</p><h2 id="软件过程的三层含义"><a href="#软件过程的三层含义" class="headerlink" title="软件过程的三层含义"></a>软件过程的三层含义</h2><ol><li>个体：软件产品或系统在生存周期中的某一类活动的集合，如系统分析过程、实现过程</li><li>整体：软件产品或系统在所有上述含义下的软件过程的总体</li><li>工程：应用软件工程原则、方法来构造软件过程的模型，并应用到软件产品的生存中，以此来提升软件生产率，降低生产成本</li></ol><h2 id="经典软件过程模型"><a href="#经典软件过程模型" class="headerlink" title="经典软件过程模型"></a>经典软件过程模型</h2><ol><li><p>瀑布模型 ($\textcolor{red}{重点}$)</p><ol><li>核心思想：将软件开发的各个过程以线性的、顺序的方式进行<ol><li>首先，清晰地了解要解决问题的需求</li><li>然后顺序地开展策划、建模、构建和部署等工作</li><li>最终交付完整的软件产品，并开展后续的技术支持和维护</li></ol></li><li>反映了一种软件开发过程理想<ol><li>每个阶段的具体活动内容和目标都清晰定义</li><li>阶段性的产出都能被明确签核（sign-off）</li><li>前一个阶段完成后才会进入下一个阶段</li></ol></li><li>想对于早期软件过程定义不清晰、缺乏工程化开发方法而言是一大进步</li></ol></li><li><p>增量模型</p><ol><li>核心思想：将开发过程分成若干增量，每次增量选择一部分需求作为交付目标，产出一个可执行的中间产品</li></ol></li><li><p>演化模型</p><ol><li>核心思想：通过“迭代”来应对不断演变的需求</li><li>螺旋模型：风险驱动的周期性迭代</li><li>原型开发：客户与开发团队之间有效沟通的重要技术手段<ol><li>抛弃式原型</li><li>增量式原型</li></ol></li></ol></li><li><p>统一过程模型</p><ol><li>核心思想：增量、迭代的过程流，每个迭代涉及核心过程工作流和核心支持工作流中的多个过程</li></ol><p>增量迭代，用例驱动，以体系结构为中心</p></li></ol><h2 id="计划驱动："><a href="#计划驱动：" class="headerlink" title="计划驱动："></a>计划驱动：</h2><ol><li>遵循计划，按部就班，过程与工具，详尽的文档</li><li>传统工程化思维稳定、便于协调</li><li>过程：所有过程活动均事先计划，按照计划衡量进度</li></ol><h2 id="敏捷开发："><a href="#敏捷开发：" class="headerlink" title="敏捷开发："></a>敏捷开发：</h2><ol><li>适应变化，快速迭代，个体与交换，可运行的代码</li><li>充分考虑软件的特点，灵活便于调整</li><li>只做增量的短期计划并根据变化和反馈不断进行调整</li><li>特点：<ol><li>客户需求驱动</li><li>计划都是短期</li><li>迭代开发软件的同时强调构造活动</li><li>频繁交付</li><li>适应性调整</li></ol></li><li>12条开发原则（判断题）：<ol><li>持续不断的，及早的交付有价值的软件</li><li>经常的交付可工作的软件</li><li>拥抱变化</li><li>可持续开发</li><li>持续的追求技术卓越和良好的设计</li></ol></li><li>敏捷实践方法论：<ol><li>Scrum：<ol><li>价值观：承诺、聚焦、开发、尊重、勇气</li><li>主要特征：<ol><li>基于时间盒的迭代</li><li>增量以及演进式开发</li></ol></li></ol></li><li>XP(极限编程)</li><li>看板方法(Kanban)</li></ol></li></ol><p>敏捷宣言（判断题）：</p><ol><li>个体和交互重于过程和工具</li><li>工作的软件重于详尽的文档</li><li>客户合作重于合同谈判</li><li>响应变化重于遵循计划</li></ol><p>什么是开发运维一体化：</p><h2 id="什么是持续集成：开发人员频繁地（一天多次）将代码变更提交合并到中央存储库，并自动运行构建和执行单元测试，从而确保新代码可以和原有代码正确地集成在一起如果持续集成失败，开发团队就要停下手中的工作，立即修复它，直到持续集成成功"><a href="#什么是持续集成：开发人员频繁地（一天多次）将代码变更提交合并到中央存储库，并自动运行构建和执行单元测试，从而确保新代码可以和原有代码正确地集成在一起如果持续集成失败，开发团队就要停下手中的工作，立即修复它，直到持续集成成功" class="headerlink" title="什么是持续集成：开发人员频繁地（一天多次）将代码变更提交合并到中央存储库，并自动运行构建和执行单元测试，从而确保新代码可以和原有代码正确地集成在一起如果持续集成失败，开发团队就要停下手中的工作，立即修复它，直到持续集成成功"></a>什么是持续集成：开发人员频繁地（一天多次）将代码变更提交合并到中央存储库，并自动运行构建和执行单元测试，从而确保新代码可以和原有代码正确地集成在一起如果持续集成失败，开发团队就要停下手中的工作，立即修复它，直到持续集成成功</h2><p>目标：</p><ol><li>使正在开发的软件始终处于可工作状态</li><li>更快地发现、定位和解决错误</li><li>提高软件质量，减少验证和发布新软件所需的时间</li></ol><p>什么是持续交付：</p><ol><li>任何代码变更提交后都能够自动运行构建和执行单元测试，自动将所有代码变更部署到测试环境和类生产环境</li></ol><p>什么是持续部署：</p><ol><li>全流程自动化，无需人工干预</li><li>加快代码提交到功能部署的速度</li><li>任何代码变更提交后都能够自动运行构建和执行单元测试</li></ol><h1 id="版本开发与任务管理"><a href="#版本开发与任务管理" class="headerlink" title="版本开发与任务管理"></a>版本开发与任务管理</h1><h2 id="为什么要进行软件配置管理："><a href="#为什么要进行软件配置管理：" class="headerlink" title="为什么要进行软件配置管理："></a>为什么要进行软件配置管理：</h2><ol><li>软件变更不可避免，新的版本不断产生</li><li>软件开发是增量和迭代的</li></ol><p>配置管理：确保软件开发和变更有序进行并向客户正确的产品版本的一整套管理方法和工具</p><p>软件配置管理主要内容：</p><ol><li>版本管理</li><li>开发任务管理</li><li>构建管理</li><li>发布管理</li></ol><h1 id="软件设计"><a href="#软件设计" class="headerlink" title="软件设计"></a>软件设计</h1><h2 id="软件设计的目标："><a href="#软件设计的目标：" class="headerlink" title="软件设计的目标："></a>软件设计的目标：</h2><ol><li>软件需求和实现代码之间的桥梁</li><li>应对软件开发的复杂性挑战</li><li>应对软件开发的变化性挑战</li></ol><h2 id="软件设计思想：分解与抽象，软件设计思维的重要基础；软件体系结构"><a href="#软件设计思想：分解与抽象，软件设计思维的重要基础；软件体系结构" class="headerlink" title="软件设计思想：分解与抽象，软件设计思维的重要基础；软件体系结构"></a>软件设计思想：分解与抽象，软件设计思维的重要基础；软件体系结构</h2><ol><li>分解：将软件不断分解为更细粒度的代码单元</li><li>抽象：忽略无关细节，只保留与当前问题相关的关键信息</li></ol><p>软件体系结构：</p><ol><li>大规模软件系统需要更高层的设计考虑</li><li>给出了软件系统的顶层设计</li><li>充分体现了分解与抽象的基本原则</li></ol><p>软件体系结构的作用：</p><ol><li>软件项目分工合作的基础</li><li>确认设计方案是否能有效满足需求</li><li>为满足未来演化和复用的需要而做出规划</li><li>作为多种候选技术方案对比选择的依据</li><li>识别并降低软件实现的风险</li><li>作为相关涉众沟通和交流的基础</li></ol><p>软件重构：在不改变代码外在行为的前提下，对代码做出修改以改进程序的内部结构</p><ol><li>目的：提高软件的可维护性和可扩展性</li><li>重构可以阶段性的改进设计和实现质量，缓解内部质量退化的趋势</li><li>重构可以在多个层面上发生：<ol><li>软件系统整体行为不变，体系结构的大规模重构</li><li>软件模块整体行为不变，类级别上的详细设计进行设计重构</li><li>类行为不变，内部设计进行代码级重构</li></ol></li></ol><p>敏捷开发中的软件重构：敏捷方法所推崇的一种重要的开发实践；实现演化式设计的一种重要手段</p><ol><li>观点：好的设计是演化出来的而不是提前设计出来的</li></ol><h2 id="面向对象软件设计过程"><a href="#面向对象软件设计过程" class="headerlink" title="面向对象软件设计过程"></a>面向对象软件设计过程</h2><ol><li>设计起点：<ol><li>规模较大的软件系统：给定软件组件的设计要求，包括整体功能、对外接口等</li><li>规模较小的软件系统：整个系统的软件系统</li></ol></li><li>基本步骤：<ol><li>识别设计类</li><li>明确设计类职责和协作</li><li>细化设计类内部细节</li></ol></li></ol><h2 id="画UML类图"><a href="#画UML类图" class="headerlink" title="画UML类图"></a>画UML类图</h2><p>校园一卡通系统中的图书馆管理子系统静态结构设计</p><p><img src="https://s1.ax1x.com/2023/05/23/p9TuHDs.png"></p><p><img src="https://s1.ax1x.com/2023/05/23/p9TKoi6.png"></p><h2 id="顺序图"><a href="#顺序图" class="headerlink" title="顺序图"></a>顺序图</h2><p>校园一卡通系统中的图书馆管理子系统动态交互设计</p><p><img src="https://s1.ax1x.com/2023/05/23/p9T12fx.png"></p><h2 id="状态图"><a href="#状态图" class="headerlink" title="状态图"></a>状态图</h2><p>bookcopy()类的行为设计</p><p><img src="https://s1.ax1x.com/2023/05/23/p9T1O9P.png"></p><h2 id="用例图"><a href="#用例图" class="headerlink" title="用例图"></a>用例图</h2><h2 id="内聚和耦合：模块独立性通常用内聚度和耦合度来衡量"><a href="#内聚和耦合：模块独立性通常用内聚度和耦合度来衡量" class="headerlink" title="内聚和耦合：模块独立性通常用内聚度和耦合度来衡量"></a>内聚和耦合：模块独立性通常用内聚度和耦合度来衡量</h2><ol><li>高内聚的模块化设计：<ol><li>强调模块的职责应该明确且专一，而且所包含的内容应与职责密切相关的部分</li><li>常见内聚形态：功能内聚、层次内聚、通信内聚、顺序内聚、过程内聚、时间内聚、功用内聚</li></ol></li><li>低耦合的模块化设计：<ol><li>模块间的依赖尽可能少</li><li>模块更容易被单独取出并在其他项目中复用</li><li>常见的耦合形态：内容耦合、共用耦合、控制耦合、印记耦合、数据耦合、过程调用、类型使用、文件包含和包引入、外部依赖</li></ol></li></ol><h2 id="面向对象设计原则：主要目标是可维护性和可扩展性，即软件设计及实现代码容易理解、修改以及扩展新功能和新特性"><a href="#面向对象设计原则：主要目标是可维护性和可扩展性，即软件设计及实现代码容易理解、修改以及扩展新功能和新特性" class="headerlink" title="面向对象设计原则：主要目标是可维护性和可扩展性，即软件设计及实现代码容易理解、修改以及扩展新功能和新特性"></a>面向对象设计原则：主要目标是可维护性和可扩展性，即软件设计及实现代码容易理解、修改以及扩展新功能和新特性</h2><ol><li>单一职责原则：每个类、接口、方法都应该只具有单一的职责，只会因为一个原因发生变化<ol><li>强调的是类、接口、方法的内聚性</li><li>内聚性越高，职责越单一</li><li>类与方法相比粒度更大，类具有更少、更聚焦的职责</li></ol></li><li>开闭原则：对扩展开发，对修改封闭即增加新功能或新特性时应扩展新的代码单元，而不是修改已有的代码单元<ol><li>直接体现了软件设计的可扩展性目标</li><li>关键在于引入适当抽象并为未来留下扩展空间</li></ol></li><li>里氏替换原则：子类对象可以出现在任何父类出现的地方</li><li>迪米特法则：强调不要和陌生人说话，只与朋友交谈<ol><li>陌生人：其他的类</li><li>朋友：其属性、方法参数或返回值对象</li><li>尽量通过已有的联系满足所需要的请求，而不要在引入新的类依赖</li></ol></li><li>接口隔离原则：多个服务于特定请求方的接口好过一个通用接口，不要强迫一个类依赖他不会使用的接口</li><li>依赖转置原则：强调尽量依赖于抽象（抽象类、接口）而非具体（实现类）<ol><li>通过抽象可以只保留关键的部分，不用引入无关的部分</li><li>依赖于抽象有利于长期的演化和维护</li></ol></li></ol><p>面向切面编程：支持横切关注点解耦和模块化封装，为改进软件设计提供了支持</p><ol><li>切面：实现关注点的模块化单元</li><li>通知：由切面所封装，将插入到基本程序中指定地方执行的功能代码</li><li>连接点：基本程序结构或者执行流上一种可以明确定义的位置</li><li>实现方式：<ol><li>借助具体的语言或框架</li><li>AOP语言扩展及编程框架</li><li>Spring AOP</li></ol></li></ol><h1 id="软件复用"><a href="#软件复用" class="headerlink" title="软件复用"></a>软件复用</h1><p>软件复用层次：代码复用，设计结果复用，分析结果复用，测试信息复用</p><ol><li>组件级软件复用：实现特定功能和特性，主要形式是软件组织</li><li>框架级软件复用：获得支撑应用运行的整体性框架，主要形式是各种软件开发框架</li><li>平台级软件复用</li></ol><h1 id="软件体系结构"><a href="#软件体系结构" class="headerlink" title="软件体系结构"></a>软件体系结构</h1><h2 id="4-1视图"><a href="#4-1视图" class="headerlink" title="4+1视图"></a>4+1视图</h2><ol><li>用例视图</li></ol><p><img src="https://s1.ax1x.com/2023/05/23/p9TwWO1.png"></p><ol><li>逻辑视图</li><li>实现试图</li><li>运行试图</li><li>部署试图</li></ol><h1 id="软件需求"><a href="#软件需求" class="headerlink" title="软件需求"></a>软件需求</h1><p>敏捷开发中的需求工程：不使用正式的需求文档，而是经常增量的收集需求并以用户故事的形式写在卡片或白板上</p><ol><li>用户故事：<ol><li>从从用户视角出发表述的端到端的细粒度功能，是对用户有价值功能点的简洁描述</li><li>用户故事之间是解耦的，每个用户故事都可以独立交付</li><li>大的用户故事一般被称为史诗故事（Epic）</li><li>用户故事的INVEST原则：<ol><li>I：独立</li><li>N：可协商</li><li>V：有价值</li><li>E：可估算工作量及进度</li><li>S：足够小，可以在一个迭代内完成</li><li>T：可测试，</li></ol></li></ol></li></ol><h1 id="软件测试"><a href="#软件测试" class="headerlink" title="软件测试"></a>软件测试</h1><p>测试观点（判断题）</p><h2 id="软件测试的定义："><a href="#软件测试的定义：" class="headerlink" title="软件测试的定义："></a>软件测试的定义：</h2><ol><li>ISO/IEEE等给出的定义：在指定条件下执行，观察或记录执行结果，并对系统或组件的某些方面进行评估的活动</li><li>ISTQB的定义：所以静态和动态活动组成的过程，目的是发现软件系统中的缺陷、提供涉众对软件系统质量的信心，以及预防软件系统中的缺陷</li><li>IEEE SWEBOK（软件工程知识体系）给出的定义：一个动态的过程，一组有限的测试用例执行待测试程序，目的是验证程序是否提供了预期的行为</li></ol><h2 id="软件测试的几个重要方面："><a href="#软件测试的几个重要方面：" class="headerlink" title="软件测试的几个重要方面："></a>软件测试的几个重要方面：</h2><ol><li>几个关键理解<ol><li>对软件进行人工或自动测试</li><li>基于预期的软件行为测试</li><li>主要目的是发现问题</li><li>需要对软件在测试中的实际行为和预期行为进行比较</li></ol></li><li>广义上的软件测试：涵盖了一切针对软件质量的检查和评价</li><li>狭义上的软件测试：通过人工或自动化的方式运行软件并对结果进行观察和分析</li></ol><h2 id="软件测试的基本过程：通过将测试用例输入到完整的系统软件或某个层次的模块上，得到实际输出，再将实际输出与测试用例的预期输出进行比较"><a href="#软件测试的基本过程：通过将测试用例输入到完整的系统软件或某个层次的模块上，得到实际输出，再将实际输出与测试用例的预期输出进行比较" class="headerlink" title="软件测试的基本过程：通过将测试用例输入到完整的系统软件或某个层次的模块上，得到实际输出，再将实际输出与测试用例的预期输出进行比较"></a>软件测试的基本过程：通过将测试用例输入到完整的系统软件或某个层次的模块上，得到实际输出，再将实际输出与测试用例的预期输出进行比较</h2>]]></content>
      
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/posts/0.html"/>
      <url>/posts/0.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h1><h2 id="查询数据库"><a href="#查询数据库" class="headerlink" title="查询数据库"></a>查询数据库</h2><pre class="line-numbers language-none"><code class="language-none">show datebases;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h2><pre class="line-numbers language-none"><code class="language-none">#直接创建数据库create datebase 数据库1;#判断创建，如果不存在数据库2就创建create datebase if not exists 数据库2;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h2><pre class="line-numbers language-none"><code class="language-none">drop datebase 数据库1;drop datebase if exists 数据库1;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="查看当前正在使用的数据库"><a href="#查看当前正在使用的数据库" class="headerlink" title="查看当前正在使用的数据库"></a>查看当前正在使用的数据库</h2><pre class="line-numbers language-none"><code class="language-none">select datebase();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="使用数据库"><a href="#使用数据库" class="headerlink" title="使用数据库"></a>使用数据库</h2><pre class="line-numbers language-none"><code class="language-none">use 数据库1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="数据库表操作"><a href="#数据库表操作" class="headerlink" title="数据库表操作"></a>数据库表操作</h1><h2 id="查询表"><a href="#查询表" class="headerlink" title="查询表"></a>查询表</h2><pre class="line-numbers language-none"><code class="language-none"># 查询所有表show tables;# 查看表结构desc 表名<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h2><pre class="line-numbers language-none"><code class="language-none">create table(    字段名 数据类型,    字段名 数据类型,    ...    字段名 数据类型);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p><a href="https://imgse.com/i/ppizx1K"><img src="https://s1.ax1x.com/2023/03/02/ppizx1K.png" alt="H9yBpn.png"></a></p><h2 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h2><pre class="line-numbers language-none"><code class="language-none">drop table 表名;drop table if exists 表名<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="修改表"><a href="#修改表" class="headerlink" title="修改表"></a>修改表</h2><pre class="line-numbers language-none"><code class="language-none">#修改表名alter table 表名 rename to 新表名;#添加一列alter table 表名 add 列名 数据类型;#修改数据类型alter table 表名 modify 列名 新数据类型;#修改类名数据类型alter table 表名 change 列名 新列名 新数据类型;#删除列alter table 表名 drop 列名;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="数据库数据操作"><a href="#数据库数据操作" class="headerlink" title="数据库数据操作"></a>数据库数据操作</h1><h2 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h2><pre class="line-numbers language-none"><code class="language-none">#指定列添加数据insert into 表名(列1,列2,...) valuse(值1,值2,...);#给全部列添加数据insert into 表名 valuse(值1,值2,...);#批量添加数据insert into 表名(列1,列2,...) values(值1,值2,...),(值1,值2,...),(值1,值2,...)...;insert into 表名 values(值1,值2,...),(值1,值2,...),(值1,值2,...)...;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="修改表数据"><a href="#修改表数据" class="headerlink" title="修改表数据"></a>修改表数据</h2><pre class="line-numbers language-none"><code class="language-none">update 表名 set 列1=值1,列2=值2,...[where 条件];# 不加条件将修改全部<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h2><pre class="line-numbers language-none"><code class="language-none">delete from 表名 [where 条件]# 不加条件将删除全部<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h1 id="数据库查询操作"><a href="#数据库查询操作" class="headerlink" title="数据库查询操作"></a>数据库查询操作</h1><h2 id="查询多个字段"><a href="#查询多个字段" class="headerlink" title="查询多个字段"></a>查询多个字段</h2><pre class="line-numbers language-none"><code class="language-none">select 字段列表 from 表名;select * from 表名;-- 查询所有数据<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="去除重复记录"><a href="#去除重复记录" class="headerlink" title="去除重复记录"></a>去除重复记录</h2><pre class="line-numbers language-none"><code class="language-none">select distinct 字段列表 from 表名;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="起别名"><a href="#起别名" class="headerlink" title="起别名"></a>起别名</h2><pre class="line-numbers language-none"><code class="language-none">#as[as可以省略]select name,math [as] 数学成绩,english from 表名;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h2><pre class="line-numbers language-none"><code class="language-none">select * from 表名 where 条件;#查询年龄15到20之间的人select name from 表名 where age between 15 and 20;#查询年龄15或20的人select name from 表名 where age = 15 or age = 20;select name from 表名 where age in(18,20);#查询成绩为null的人select name from 表名 grade is null;#查询成绩不为null的人select name from 表名 grade is not null;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://imgse.com/i/ppizz6O"><img src="https://s1.ax1x.com/2023/03/02/ppizz6O.png"></a></p><h2 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h2><p>通配符：</p><p><strong>_</strong>:$\textcolor{red}{代表单个任意字符}$</p><p><strong>%</strong>:$\textcolor{red}{代表任意个数的字符}$</p><pre class="line-numbers language-none"><code class="language-none">#查询姓w的人select * from 表名 where name like 'w%';;#查询第二个字是w的人select * from 表名 where name like '_w%';#查询名字包含w的人select * from 表名 where name likr '%w%';<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="排序查询"><a href="#排序查询" class="headerlink" title="排序查询"></a>排序查询</h2><pre class="line-numbers language-none"><code class="language-none">select 字段列表 from 表名 order by 排序字段名1 [排序方式1],排序字段名2 [排序方式2]...;# 按年龄升序排列select * from 表名 order by age;select * from 表名 order by age asc;# 按成绩排列如果成绩一样则按年龄升序排列select * from 表名 order by grade desc,age asc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>排序方式：ASC升序（默认方式）</p><p>​           DESC：降序</p><p>$\textcolor{red}{如果有多个排序条件，当前面条件值一样时，才会按照第二天排序}$</p><h2 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h2><p>聚合函数：将一列数据作为一个整体，进行纵向计算</p><pre class="line-numbers language-none"><code class="language-none">select 聚合函数(列名) from 表名;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><a href="https://imgse.com/i/ppizvp6"><img src="https://s1.ax1x.com/2023/03/02/ppizvp6.png"></a></p><p>$\textcolor{red}{null值不参与所有聚合函数函数运算}$</p><h2 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h2><pre class="line-numbers language-none"><code class="language-none">select 字段列表 from 表名 [where 分组前条件限定] group by 分组字段名 [having 分组后条件过滤]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>$\textcolor{red}{分组之后，查询的字段为聚合函数和分组字段，查询其他字段无意义}$</p><p>$\textcolor{red}{where和having的区别：}$ 执行时机不一样，where分组前，having分组后</p><p>​                        判断条件不同，having可以对聚会函数判断，where不可以</p><p>执行顺序：where&gt;聚合函数&gt;having</p><h2 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h2><pre class="line-numbers language-none"><code class="language-none">select 字段列表 from 表名 limit 起始索引,查询条目数;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>起始索引(从0开始)=(当前页码-1)*每页显示的条数</p><h1 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h1><p>可以在$\textcolor{red}{建表时添加约束，也可以建表后添加}$</p><p>==建表后==</p><pre class="line-numbers language-none"><code class="language-none"># 非空和唯一约束alter table 表名 modify 字段名 数据类型 关键字# 主键约束alter table 表名 add primary key(字段名)# 默认约束alter table 表名 alter 列名 set default 默认值# 检查约束alter table 表名 add constraint 检查约束名· check(检查约束)# 外键约束alter table 表名 add constraint 外键名称 foreign key (外键字段名称) references 主表名称(主表列名称)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>==删除约束==</p><pre class="line-numbers language-none"><code class="language-none"># 非空约束alter table 表名 modify 字段名 数据类型# 唯一约束alter table 表名 modify drop index 字段名# 主键约束alter table 表名 drop primary key# 默认约束alter table 表名 alter 列名 drop default#检查约束alter table 表名 drop constraint 检查约束名# 外键约束alter table 表名 drop foreign key 外键名称<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="非空约束"><a href="#非空约束" class="headerlink" title="非空约束"></a>非空约束</h2><p>关键字：NOT NULL</p><pre class="line-numbers language-none"><code class="language-none">create table stu(int age not null, #非空)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="唯一约束"><a href="#唯一约束" class="headerlink" title="唯一约束"></a>唯一约束</h2><p>关键字：UNIQUE</p><pre class="line-numbers language-none"><code class="language-none">create table stu(age int not null, # 非空name varchar(50) not null unique, # 非空且唯一)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="主键约束"><a href="#主键约束" class="headerlink" title="主键约束"></a>主键约束</h2><p>关键字：PRIMARY KEY</p><pre class="line-numbers language-none"><code class="language-none">create table stu(id int primary key auto_increment,# 主键且自增长age int not null, # 非空name varchar(50) not null unique, # 非空且唯一)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="检查约束"><a href="#检查约束" class="headerlink" title="检查约束"></a>检查约束</h2><p>关键字：CHECK</p><pre class="line-numbers language-none"><code class="language-none">create table stu(id int primary key auto_increment,# 主键且自增长age int not null, # 非空name varchar(50) not null unique, # 非空且唯一check(age &gt; 18 and age &lt; 60),)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="默认约束"><a href="#默认约束" class="headerlink" title="默认约束"></a>默认约束</h2><p>关键字：DEFAULT</p><pre class="line-numbers language-none"><code class="language-none">create table stu(id int primary key,# 主键且自增长age int not null, # 非空name varchar(50) not null unique, # 非空且唯一bonus double(7,2) default 0 # 没有默认为0)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h2><p>关键字：FOREIGN KEY    </p><pre class="line-numbers language-none"><code class="language-none">create table stu(id int primary key,# 主键且自增长age int not null, # 非空name varchar(50) not null unique, # 非空且唯一bonus double(7,2) default 0 # 没有默认为0teache varchar(50)constraint 外键名称 foreign key(外键列名) refernnces 主表(主表列名))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>两个表之间建立连接</p><h1 id="表关系"><a href="#表关系" class="headerlink" title="表关系"></a>表关系</h1><h2 id="一对多"><a href="#一对多" class="headerlink" title="一对多"></a>一对多</h2><p>一个部门对应多个员工</p><p>$\textcolor{red}{在多的一方建立外表，指向一的一方主键}$</p><h2 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h2><p>商品与订单</p><p>$\textcolor{red}{建立第三张中间表，中间表至少包含两个外键，分别关联两方主键}$</p><h2 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h2><p>用户和用户详情</p><p>多用于表的拆分，将一个实体中经常使用的字段放一张表，不常用的字段放一张表</p><p>$\textcolor{red}{在任意一方加入外键，关联另一方的主键，并且外键唯一}$</p><h1 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h1><pre class="line-numbers language-none"><code class="language-none">select * from 表1, 表2; -- 缺点会产生笛卡尔积：有A，B两个集合，去A，B所有组合情况# 消除无效数据select * from 表1, 表2 where 条件; -- 连接查询# 内连接：查询A，B的交集/*外连接：  左外连接：相当于查询A表所有数据和交集部分数据  右外连接：相当于查询B表所有数据和交集部分数据*/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="内-amp-外连接"><a href="#内-amp-外连接" class="headerlink" title="内&amp;外连接"></a>内&amp;外连接</h2><pre class="line-numbers language-none"><code class="language-none"># 隐式内连接select 字段列表 from 表1, 表2... where 条件# 显示内连接select 字段列表 from 表1 [inner] join 表2 on 条件# 左外连接select 字段列表 from 表1 LEFT [outer] join 表2 on 条件# 右外连接select 字段列表 from 表1 right [outer] join 表2 on 条件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="子查询（嵌套查询）"><a href="#子查询（嵌套查询）" class="headerlink" title="子查询（嵌套查询）"></a>子查询（嵌套查询）</h2><pre class="line-numbers language-none"><code class="language-none"># 单行单列：使用=!=&gt;&lt;等进行条件判断select 字段列表 from 表 where 字段名 = (select ...);# 多行多列：使用in关键字进行条件判断select 字段列表 from 表 where 字段名 in (子查询(select ...));# 多行多列：作为虚拟表select 字段列表 from (子查询) where 条件;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>一种机制，一个操作序列，包含一组操作数据库指令</p><p>同时成功，同时失败</p><p>不可分开的工作逻辑单元</p><pre class="line-numbers language-none"><code class="language-none"># 开启事务start transaction或者begin# 提交事务commit# 回滚事务（出异常时）rollback<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>$\textcolor{red}{事务四大特征}$:</p><pre><code>           1. 原子性：最小操作单位，同时成功同时失败        2. 一致性：事务完成时，所有数据都保持一致状态        3. 隔离性：多个事务之间，操作的可见性        4. 持久性：事务一旦提交或回滚，对数据库中数据的改变是永久的</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>KNN</title>
      <link href="/posts/7c10b52f.html"/>
      <url>/posts/7c10b52f.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="什么是KNN"><a href="#什么是KNN" class="headerlink" title="什么是KNN"></a>什么是KNN</h1><p>K近邻（KNN）算法是一种分类和回归算法，一个未知样本与<strong>数据集</strong>中的K个样本最相似，如果这K个样本中的大多数属于一类，则这未知样本也属于该类</p><p>简单的说就是每个样本都可以用与他最近的K个邻居来代表</p><h1 id="KNN算法"><a href="#KNN算法" class="headerlink" title="KNN算法"></a>KNN算法</h1><hr><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol><li>收集数据</li><li>以所有已知类实例作为参照选择参数K</li><li>计算未知实例与所有已知实例的距离</li><li>选择最近的K个实例（一般取奇数，偶数容易会出现误差）</li><li>判断未知实例属于哪一个类</li></ol><hr><h2 id="判断距离"><a href="#判断距离" class="headerlink" title="判断距离"></a>判断距离</h2><ol><li><a href="https://blog.csdn.net/bluesliuf/article/details/88862918">欧式距离</a></li><li><a href="https://blog.csdn.net/bluesliuf/article/details/88862918">马氏距离</a></li><li><a href="https://blog.csdn.net/qq_39362996/article/details/96896568">曼哈顿距离</a></li></ol><hr><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>优点：精度高，对异常值不敏感，无数据输入假定</p><p>缺点：计算复杂度高，空间复杂度高；在样本分布不平衡时，大样本占主导地位</p><hr><h2 id="Python实现"><a href="#Python实现" class="headerlink" title="Python实现"></a>Python实现</h2><table><thead><tr><th align="center">电影名称</th><th align="center">打斗镜头</th><th align="center">接吻镜头</th><th align="center">电影类型</th></tr></thead><tbody><tr><td align="center">Californian Man</td><td align="center">3</td><td align="center">104</td><td align="center">爱情片</td></tr><tr><td align="center">He’s Not Really into Dudes</td><td align="center">2</td><td align="center">100</td><td align="center">爱情片</td></tr><tr><td align="center">Beautiful Woman</td><td align="center">1</td><td align="center">81</td><td align="center">爱情片</td></tr><tr><td align="center">Kevin Longblade</td><td align="center">101</td><td align="center">10</td><td align="center">动作片</td></tr><tr><td align="center">RobotSlayer 3000</td><td align="center">99</td><td align="center">5</td><td align="center">动作片</td></tr><tr><td align="center">Amped 2</td><td align="center">98</td><td align="center">2</td><td align="center">动作片</td></tr><tr><td align="center">？</td><td align="center">18</td><td align="center">90</td><td align="center">未知</td></tr></tbody></table><p>注：样例来自<a href="https://book.douban.com/subject/24703171/">《机器学习实战》</a> </p><p>先将样例画出散点图很容易判断？属于爱情片</p><pre class="line-numbers language-none"><code class="language-none">"""作者：wenlwei"""import numpy as npimport matplotlib.pyplot as pltimport operator# 爱情篇的打斗镜头x_1 = np.array([3, 2, 1])# 爱情篇的接吻镜头y_1 = np.array([104, 100, 81])# 动作片的打斗镜头x_2 = np.array([101, 99, 98])# 动作片的接吻镜头y_2 = np.array([10, 5, 2])# 未知样例x_3 = np.array([18])y_3 = np.array([90])# 散点图scatter_1 = plt.scatter(x_1, y_1, c = 'g')scatter_2 = plt.scatter(x_2, y_2, c = 'r')scatter_3 = plt.scatter(x_3, y_3, c = 'k')# 画图，标签plt.legend(handles = [scatter_1, scatter_2, scatter_3], labels = ['A', 'B', 'X'], loc = 'best')plt.show()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://s4.ax1x.com/2022/02/28/bKz259.png"></p><p><strong>算法实现</strong></p><pre class="line-numbers language-none"><code class="language-none">"""作者：wenlwei"""import numpy as npimport matplotlib.pyplot as pltimport operator# 已知数据，标签，未知数据x_data = np.array([[3, 104],                  [2, 100],                  [1, 81],                  [101, 10],                  [99, 5],                  [98, 2]])y_label = np.array(['A', 'A', 'A', 'B', 'B', 'B'])x_test = np.array([18, 90])# 已知样本数量x_data_size = x_data.shape[0]# 因为要计算未知样例与所有样例的距离所有需要复制x_test# 行复制x_data_size次，列复制1次diffMat = np.tile(x_test, (x_data_size, 1)) - x_data# 插值的平方sq_diffMat = diffMat**2# 求和sq_sum = sq_diffMat.sum(axis=1)# 开方sqrt_sq_sum = sq_sum**0.5# 按升序排序'''argsort函数返回的是索引例：array = [12, 10, 45, 11, 13]排序后为array = [1, 3, 0, 4, 2]分别对应10，11，12，13，45'''sort_sqrt_sq_sum = sqrt_sq_sum.argsort()# 定义一个空字典，记录标签classCount = {}# 设K=3for i in range(3):    # 获取标签    votelabel = y_label[sort_sqrt_sq_sum[i]]    # 如果不存在就get(0)    classCount[votelabel] = classCount.get(votelabel, 0) + 1# 对classCount排序,True表示倒叙sortedclassCount = sorted(classCount.items(), key=operator.itemgetter(1), reverse=True)# 获取最多的标签判断x_testknn = sortedclassCount[0][0]print(knn)运行结果：A<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>通过结果可以知道knn=A，即？距离k个样例中爱情片最近</strong></p><p>参考文献:</p><p><a href="https://book.douban.com/subject/24703171/">《机器学习实战》</a></p><hr>]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习</title>
      <link href="/posts/498ab7d9.html"/>
      <url>/posts/498ab7d9.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h1><h2 id="机器学习基础"><a href="#机器学习基础" class="headerlink" title="机器学习基础"></a>机器学习基础</h2><p>什么是机器学习？</p><p>通过对信息的统计来利用信息建立模型然后使用模型预测的方法。即将大量的数据转换成有用的信息。</p><p><del>为什么要进行机器学习？</del></p><p>机器学习的<strong>主要任务</strong>：<strong>回归</strong>，<strong>分类</strong></p><p><strong>分类</strong>：将实例数据进行合适分类</p><p><strong>回归</strong>：主要用于预测数值型数据</p><p><strong>训练集</strong>：拥有已大量分类的数据，是用于训练机器学习算法的数据样本集合</p><p><strong>目标变量</strong>：是机器学习算法的预测结果，<strong>分类算法</strong>中目标变量通常是<strong>标称型</strong>，<strong>回归算法</strong>中通常是<strong>连续型</strong></p><p><strong>注意</strong>：<strong>特征或属性</strong>通常是训练样本集的列，是独立测量得到的结果，<strong>多个</strong>特征联系在一起共同组成一个训练样本</p><p><strong>训练数据</strong>：机器学习<strong>开始</strong>时作为算法输入的训练样本集</p><p><strong>测试数据</strong>：训练<strong>完成</strong>后输入的训练样本集</p><p><strong>注</strong>：测试样本时不提供目标变量，由程序决定</p><p>分类和回归都称为<strong>监督学习</strong>，这类算法必须知道要预测什么，即目标变量的分类信息</p><p><strong>无监督学习</strong>即数据没有类别信息，也不给定目标值</p><p><strong>聚类</strong>：无监督学习中，将数据集合分成类似的对象组成的多个类的过程</p><p><strong>密度估计</strong>：寻找描述数据统计值的过程</p><p>无监督学习可以减少数据特征的维度</p><table><thead><tr><th align="center">监督学习的用途</th><th align="center">无监督学习的用途</th></tr></thead><tbody><tr><td align="center">k-近邻算法</td><td align="center">K-均值</td></tr><tr><td align="center">朴素贝叶斯算法</td><td align="center">DBSCAN</td></tr><tr><td align="center">支持向量机</td><td align="center">最大期望算法</td></tr><tr><td align="center">决策树</td><td align="center">Parzem窗设计</td></tr><tr><td align="center">线性回归</td><td align="center"></td></tr><tr><td align="center">局部加权线性回归</td><td align="center"></td></tr><tr><td align="center">Ridge回归</td><td align="center"></td></tr><tr><td align="center">Lasso最小回归系数估计</td><td align="center"></td></tr></tbody></table><hr><h2 id="怎样选择算法"><a href="#怎样选择算法" class="headerlink" title="怎样选择算法"></a>怎样选择算法</h2><p>使用机器学习算法的目的，想要算法完成何种任务</p><p>需要分析或收集的数据是什么</p><p>例如监督学习</p><p><a href="https://imgtu.com/i/HCNOje"><img src="https://s4.ax1x.com/2022/01/30/HCNOje.png" alt="HCNOje.png"></a></p><h1 id="Numpy库基础"><a href="#Numpy库基础" class="headerlink" title="Numpy库基础"></a>Numpy库基础</h1><h2 id="创建随机数组"><a href="#创建随机数组" class="headerlink" title="创建随机数组"></a>创建随机数组</h2><pre class="line-numbers language-none"><code class="language-none">from numpy import *random.rand(4,4)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="创建随机矩阵"><a href="#创建随机矩阵" class="headerlink" title="创建随机矩阵"></a>创建随机矩阵</h2><pre class="line-numbers language-none"><code class="language-none">from numpy import *randMat = mat (random.rand(4,4))randMat<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="逆矩阵"><a href="#逆矩阵" class="headerlink" title="逆矩阵"></a>逆矩阵</h3><pre class="line-numbers language-none"><code class="language-none">randMat.I<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="存储矩阵"><a href="#存储矩阵" class="headerlink" title="存储矩阵"></a>存储矩阵</h2><pre class="line-numbers language-none"><code class="language-none">invRandMat = randMat.I<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="矩阵相乘"><a href="#矩阵相乘" class="headerlink" title="矩阵相乘"></a>矩阵相乘</h2><pre class="line-numbers language-none"><code class="language-none">randMat*invRandMat<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="单位矩阵"><a href="#单位矩阵" class="headerlink" title="单位矩阵"></a>单位矩阵</h2><pre class="line-numbers language-none"><code class="language-none">from numpy import *randMat = mat (random.rand(4,4))randMat.IinvRandMat = randMat.IrandMat*invRandMat# 得误差值myEye = randMat*invRandMatmyEye - eye(4)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="k-近邻算法"><a href="#k-近邻算法" class="headerlink" title="k-近邻算法"></a>k-近邻算法</h1>]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java类</title>
      <link href="/posts/46779f67.html"/>
      <url>/posts/46779f67.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Java类"><a href="#Java类" class="headerlink" title="Java类"></a>Java类</h1><h2 id="字符串类"><a href="#字符串类" class="headerlink" title="字符串类"></a>字符串类</h2><h3 id="字符串处理的类"><a href="#字符串处理的类" class="headerlink" title="字符串处理的类"></a>字符串处理的类</h3><p><strong>String，StringBuffer</strong></p><p><strong>SringTokenizer</strong></p><p><strong>StringBuilder</strong></p><p><strong>StreamTokenozer</strong></p><hr><h3 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h3><p>String类定义的字符串是不可变长的。</p><p>String类是final类，是不可改变的，所以其创建对象的值无法改变。</p><p>String类中提供更改对象内容的方法并未真正更改内容，而是创建一个新的对象并返回。</p><p>字符串常量存储在<strong>常量池</strong>中，且常量唯一</p><p>直接引用字符串常量引用的是常量池中定义的常量，若<strong>无则创建</strong>。</p><p>通过<strong>构造方法</strong>创建，在堆内存中创建变量</p><p>exp： String str =  new String(“Java”);</p><p>exp：String str1=“Java”；</p><p>​       String str2=“Java”；</p><p>str1,str2引用的是同一实体Java</p><p>str1**==<strong>str2比较的是</strong>地址**</p><p>String s1 = new String(“World”);</p><p>String s2 = new String(“World”);</p><p>String s3 = “World”;</p><p>s1、s2分别在堆内存中分别创建一个World实体。</p><p>s1==s2不成立(<strong>地址</strong>)</p><p>s2==s3不成立(<strong>地址</strong>)</p><p>s2.<strong>equals</strong>(s3)成立</p><hr><h3 id="String对象是不可变的"><a href="#String对象是不可变的" class="headerlink" title="String对象是不可变的"></a>String对象是不可变的</h3><p>s1=“Hello”；</p><p>s1=“Hello Java”</p><p>创建了一个新的对象 “Hello Java”，而原来的 “Hello” 还存在于内存中</p><hr><h3 id="String类常用方法"><a href="#String类常用方法" class="headerlink" title="String类常用方法"></a>String类常用方法</h3><table><thead><tr><th align="center">返回类型</th><th align="center">方法名</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center"></td><td align="center">Sting()</td><td align="center">创建一个空字符串对象</td></tr><tr><td align="center"></td><td align="center">String(char value)</td><td align="center">用字符数组value创建一个字符串对象</td></tr><tr><td align="center"></td><td align="center">String(String str)</td><td align="center">用字符串对象创建一个心的字符串对象</td></tr><tr><td align="center">char[]</td><td align="center">toCharArray()</td><td align="center">将字符串转化为字符数组</td></tr><tr><td align="center">cahr</td><td align="center">charAt(int i)</td><td align="center">返回指定索引位置的值</td></tr><tr><td align="center">int</td><td align="center">compare To(String str)</td><td align="center">按字典序比较两个字符串</td></tr><tr><td align="center">String</td><td align="center">concat(String str)</td><td align="center">将str连接到当前字符串末尾</td></tr><tr><td align="center">boolean</td><td align="center">contains(CharSequence s)</td><td align="center">此字符串包含char值序列s返回true</td></tr><tr><td align="center">boolean</td><td align="center">equals(Object obj)</td><td align="center">当前字符串与对象比较</td></tr><tr><td align="center">boolean</td><td align="center">isEmpty()</td><td align="center">判断字符串是否为空</td></tr><tr><td align="center">int</td><td align="center">index Of(String str)</td><td align="center">返回当前字符串第一次出现str的索引</td></tr><tr><td align="center">int</td><td align="center">length()</td><td align="center">返回当前字符串的长度</td></tr><tr><td align="center">boolean</td><td align="center">matches(String regex)</td><td align="center">判断当前串是否匹配正则表达式</td></tr><tr><td align="center">String</td><td align="center">replace(char&nbsp;old, char&nbsp;new)</td><td align="center">对字符串中所有字符old替换为new</td></tr><tr><td align="center">Sting[]</td><td align="center">split(String regex)</td><td align="center">按给定正则表达式的匹配拆分字符串</td></tr><tr><td align="center">boolean</td><td align="center">tartsWith(String prefix)</td><td align="center">判断当前串是否以prefix开头</td></tr><tr><td align="center">String</td><td align="center">substring(int&nbsp;begin, int&nbsp;end)</td><td align="center">返回当前字符串的一个子字符串</td></tr><tr><td align="center">String</td><td align="center">trim()</td><td align="center">删除前导空格和尾部空格</td></tr><tr><td align="center">static String</td><td align="center">valueOf(Object obj)</td><td align="center">返回 Object 参数的字符串表示形式</td></tr></tbody></table><pre class="line-numbers language-none"><code class="language-none">String str1 = new String("abc");String str2 = new String("abc");System.out.println(str1 == str2);System.out.println(str1.equals(str2));运行结果：false     true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">String str1 = "hello";String str2 = "java";int result = str1.compareTo(str2);System.out.println(result);运行结果：返回第一个不相等字符的ASCII之差-2 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">String str1 = "how are you!";int x = 97; //a的ASCII值int index = str1.indexOf(x);System.out.println(index);运行结果:4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">String str1 = "end line,end line";String str2 = str1.replace('e', 'a');System.out.println(str2);str2 = str1.replaceAll("end", "start");System.out.println(str3);运行结果：and lina,and linastart line,start line<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">String str1 = "I am a student";String str2 = str1.substring(5);System.out.println(str2);运行结果：a student<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">String str1 = "I am a student";String str2 = str1.substring(2,8);System.out.println(str2);运行结果：am a s   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">String str1 = "hello java world";String[] str2 = str1.split(" ");for(String s : str2){     System.out.println(s);}运行结果：hellojavaworld <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h3><p>StringBuffer类定义的字符串是<strong>变长</strong>的。</p><p>StringBuffer类创建对象的值<strong>允许改变</strong>，用于字符串动态变化。</p><p>常用方法包括字符串尾部追加、插入、内容替换、字符串中删除子串、字符串倒序、返回缓冲区容量等</p><hr><h3 id="StringBuffer类常用方法"><a href="#StringBuffer类常用方法" class="headerlink" title="StringBuffer类常用方法"></a>StringBuffer类常用方法</h3><table><thead><tr><th align="center">返回类型</th><th align="center">方法名</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center"></td><td align="center">StringBuffer()</td><td align="center">构造一个16字符的字符串缓冲区</td></tr><tr><td align="center"></td><td align="center">StringBuffer(int a)</td><td align="center">构造一指定容量的字符串缓冲区</td></tr><tr><td align="center"></td><td align="center">StringBuffer(String str)</td><td align="center">构造一指定串str另加16字符的缓冲区</td></tr><tr><td align="center"></td><td align="center">StringBuffer(CharSequence s)</td><td align="center">构造一字符序列s另加16字符的缓冲区</td></tr><tr><td align="center">String</td><td align="center">toString()</td><td align="center">转换为String字符串</td></tr><tr><td align="center">StringBuffer</td><td align="center">append(String str)</td><td align="center">追加字符串</td></tr><tr><td align="center">StringBuffer</td><td align="center">insert(int offset, String str)</td><td align="center">指定位置插入字符串</td></tr><tr><td align="center">StringBuffer</td><td align="center">reverse()</td><td align="center">字符翻转</td></tr><tr><td align="center">StringBuffer</td><td align="center">delete(int startIndex,int endIndex)</td><td align="center">删除startIndex与endIndex（不包括）之间的字符</td></tr><tr><td align="center">StringBuffer</td><td align="center">replace(int startIndex,int endIndex,String str)</td><td align="center">用str替换startIndex与endIndex（不包括）之间的字符</td></tr></tbody></table><pre class="line-numbers language-none"><code class="language-none">StringBuffer buffer = new StringBuffer();System.out.println(buffer.toString());buffer.append("JDK");//末尾追加buffer.append(8.0);System.out.println(buffer.toString());buffer.insert(0, "Hello ");//指定位置插入System.out.println(buffer.toString());buffer.delete(9, 12);//删除指定位置之间System.out.println(buffer.toString());运行结果：JDK8.0Hello JDK8.0Hello JDK<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">StringBuffer buffer = new StringBuffer("Hello Java!");System.out.println(buffer.toString());buffer.replace(6, 11, "Python");//替换System.out.println(buffer.toString());buffer.reverse();//翻转System.out.println(buffer.toString());运行结果：Hello Java!Hello PythonnohtyP olleH<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h3><p>StringBuilder和StringBuffer方法类似。</p><p>StringBuffer 的方法是<strong>线程安全</strong>的（不能同步访问），而StringBuilder不是。</p><hr><h3 id="String与StringBuffer比较"><a href="#String与StringBuffer比较" class="headerlink" title="String与StringBuffer比较"></a>String与StringBuffer比较</h3><h4 id="构造方法不同"><a href="#构造方法不同" class="headerlink" title="构造方法不同"></a>构造方法不同</h4><p><strong>String创建的字符串是常量，创建后不能改变</strong>；</p><p><strong>StringBuffer创建的是缓冲区，其字符串可以改变</strong>。</p><h4 id="成员方法不同"><a href="#成员方法不同" class="headerlink" title="成员方法不同"></a>成员方法不同</h4><p>String类的成员方法以只读数据为主；</p><p>StringBuffer的成员方法则可以读写字符串。</p><hr><h3 id="StringTokenizer类"><a href="#StringTokenizer类" class="headerlink" title="StringTokenizer类"></a>StringTokenizer类</h3><p>用于字符串分割，同时支持多种分隔符。</p><p>属于java.util包</p><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><p>StringTokenizer（String s），分隔标记默认为空格</p><p>StringTokenizer（String s, String delim），delim中的字符的任意排列组合都是分隔标记</p><p>public int countTokens()；// 分割串的个数</p><p>public boolean hasMoreTokens()；// 是否还有分割串</p><p>public String nextToken()；// 得到下一分割串</p><p>exp：</p><pre class="line-numbers language-none"><code class="language-none">import java.util.StringTokenizer;public class Main {public static void main(String[] args)  {        String s = "I am Jame  ,,,  you are Jerry,and he is Tom";        StringTokenizer tokenizer= new StringTokenizer(s," ,");//空格、逗号        int number = tokenizer.countTokens();// 获取单词总数        while (tokenizer.hasMoreTokens()){// 是否还有单词        String str = tokenizer.nextToken();// 获得下一个单词        System.out.println(str);        }        System.out.println("总共单词数：" + number);    } }运行结果：IamJameyouareJerryandheisTom总共单词数：10<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="数学类"><a href="#数学类" class="headerlink" title="数学类"></a>数学类</h2><p>Math（数学类）</p><p>Random（随机数类）</p><hr><h3 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h3><p>用于数学计算</p><p>Math类的所有属性和方法都是静态的</p><p>常用方法：取绝对值abs()、求最大值max()、求最小值min()、产生随机数random()、乘幂pow()、平方根sqrt()、对数log()、三角函数运算。</p><hr><h3 id="Random"><a href="#Random" class="headerlink" title="Random"></a>Random</h3><p>用于产生随机数</p><p>常用方法：支持基本类型随机数的产生。包括nextBoolean()、nextBytes()、nextDouble()、nextInt()、nextInt(int n)、nextLong()、setSeed()等。</p><p>exp：</p><pre class="line-numbers language-none"><code class="language-none">import java.util.Random;public class Main {public static void main(String[] args)  {Random r = new Random();int number = r.nextInt(10);System.out.println(number);    } }运行结果：7<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="Date类"><a href="#Date类" class="headerlink" title="Date类"></a>Date类</h2><p>Date类在包java.util</p><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><table><thead><tr><th align="center">返回类型</th><th align="center">方法名</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center"></td><td align="center">Date()</td><td align="center">构造方法，获取系统日期</td></tr><tr><td align="center">boolean</td><td align="center">after(Date d)</td><td align="center">测试此日期是否在指定日期之后</td></tr><tr><td align="center">boolean</td><td align="center">before(Date d)</td><td align="center">测试此日期是否在指定日期之前</td></tr><tr><td align="center">int</td><td align="center">compareTo(Date d)</td><td align="center">比较两个日期的顺序</td></tr><tr><td align="center">long</td><td align="center">getTime()</td><td align="center">返回自格林尼治GMT1970年1月1日00:00:00以来此 Date 对象表示的毫秒数</td></tr></tbody></table><hr><h2 id="Calendar类"><a href="#Calendar类" class="headerlink" title="Calendar类"></a>Calendar类</h2><p>日历类Calendar定义在java.util包</p><h3 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h3><table><thead><tr><th align="center">返回类型</th><th align="center">方法名</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">int</td><td align="center">get(int field)</td><td align="center">返回给定日历字段的值</td></tr><tr><td align="center">Date</td><td align="center">getTime()</td><td align="center">返回一个表示此Calemder时间值的Date对象</td></tr><tr><td align="center">long</td><td align="center">getTimeInMillis()</td><td align="center">返回以毫秒为单位的此日历的时间值</td></tr><tr><td align="center">void</td><td align="center">set(int field,int value)</td><td align="center">将给定的日历字段设置为给定值</td></tr><tr><td align="center">void</td><td align="center">setTime(Date date)</td><td align="center">使用给定的Date实例设置此Calender对象的时间</td></tr></tbody></table><hr><h2 id="日期格式化"><a href="#日期格式化" class="headerlink" title="日期格式化"></a>日期格式化</h2><p>格式化日期SimpleDateFormat类在包java.text</p><h3 id="常用方法-2"><a href="#常用方法-2" class="headerlink" title="常用方法"></a>常用方法</h3><table><thead><tr><th align="center">返回类型</th><th align="center">方法名</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center"></td><td align="center">SimpleDateFormat(String pattern)</td><td align="center">构造方法，设置格式化日期格式</td></tr><tr><td align="center">String</td><td align="center">format(Date date)</td><td align="center">格式化日期并返回字符串</td></tr><tr><td align="center">Date</td><td align="center">parse(String source)</td><td align="center">指定格式字符串转换为Date对象</td></tr></tbody></table><hr><p>exp：</p><pre class="line-numbers language-none"><code class="language-none">import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;public class Main {public static void main(String[] args)  {Date date = new Date();System.out.println(date.toString());SimpleDateFormat formater = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");System.out.println(formater.format(date));try {    date = formater.parse("2021-12-14 21:16:30");   System.out.println(date.toString());} catch (ParseException e) {}    } }运行结果：Tue Dec 14 21:17:47 CST 20212021-12-14 21:17:47Tue Dec 14 21:16:30 CST 2021<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Calendar;import java.util.Date;public class Main {public static void main(String[] args)  {Calendar calendar = Calendar.getInstance();Date date = new Date();System.out.println(date.toString());calendar.setTime(date);int month = calendar.get(Calendar.MONTH);System.out.println(month);//月份从0开始  calendar.set(Calendar.MONTH,4);System.out.println(calendar.getTime());    } }运行结果：Tue Dec 14 21:20:48 CST 202111Fri May 14 21:20:48 CST 2021<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="集合类"><a href="#集合类" class="headerlink" title="集合类"></a>集合类</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>空间自主调整，提高空间利用率，动态存储多个对象。</p><p>提供不同的数据结构和算法，减少编程工作量。</p><p>提高程序的处理速度和质量。</p><p><strong>注意</strong>：1.集合类支持引用类型，包括包装类。</p><p>2.集合类中存放的是对象的引用，而不是对象本身。</p><hr><p>集合类均采用<strong>泛型</strong>进行定义，分为 Collection 和 Map 两种体系</p><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>泛型允许类的成员的类型可以由外部程序来指定，也就是说可以以参数形式来指定类型，即“参数化类型”。常用泛型有泛型接口、泛型类、泛型方法。</p><h4 id="泛型类定义"><a href="#泛型类定义" class="headerlink" title="泛型类定义"></a>泛型类定义</h4><p>class 泛型类名&lt;类型参数表列&gt;{//类体}</p><pre class="line-numbers language-none"><code class="language-none">public class ArrayList&lt;E&gt; { } <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="泛型接口定义"><a href="#泛型接口定义" class="headerlink" title="泛型接口定义"></a>泛型接口定义</h4><p>interface 接口名&lt;类型参数表列&gt;{}</p><pre class="line-numbers language-none"><code class="language-none">public interface List&lt;E&gt;{ }<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="泛型方法定义"><a href="#泛型方法定义" class="headerlink" title="泛型方法定义"></a>泛型方法定义</h4><p>[&lt;泛型参数&gt;] 方法类型 方法名([泛型参数]){}</p><pre class="line-numbers language-none"><code class="language-none">public boolean add(E e){ }<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><h3 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h3><p>List：元素<strong>有序</strong>，<strong>可重复</strong>的集合</p><p>Set：元素<strong>无序</strong>、<strong>不可重复</strong>的集合</p><p>Collection 接口是 List、Set 接口的父接口，该接口里定义的方法既可用于操作 Set 集合，也可用于操作 List 集合。</p><h4 id="Collection接口方法"><a href="#Collection接口方法" class="headerlink" title="Collection接口方法"></a>Collection接口方法</h4><table><thead><tr><th align="center">类型</th><th align="center">方法名</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">void</td><td align="center">clear()</td><td align="center">删除当前集合中的所有元素</td></tr><tr><td align="center">boolean</td><td align="center">contains(Object o)</td><td align="center">查找当前集合中是否有指定元素</td></tr><tr><td align="center">boolean</td><td align="center">containsAll(Collection c)</td><td align="center">查找当前集合中是否包含指定集合中的所有元素</td></tr><tr><td align="center">boolean</td><td align="center">isEmpty()</td><td align="center">当前集合是否为空</td></tr><tr><td align="center">int</td><td align="center">size()</td><td align="center">返回当前集合的元素个数</td></tr><tr><td align="center">Iterator</td><td align="center">iterator()</td><td align="center">返回一个可遍历当前集合的迭代器</td></tr><tr><td align="center">Object[]</td><td align="center">toArray()</td><td align="center">返回一个当前集合所有元素的数组</td></tr><tr><td align="center">boolean</td><td align="center">add(E e)</td><td align="center">向集合中添加新元素</td></tr><tr><td align="center">boolean</td><td align="center">addAll(Collection c)</td><td align="center">将指定集合中的所有元素添加到当前集合中</td></tr><tr><td align="center">boolean</td><td align="center">remove(Object o)</td><td align="center">删除当前集合中包含的指定元素</td></tr><tr><td align="center">boolean</td><td align="center">removeAll(Collection c)</td><td align="center">删除当前集合中与指定集合相同的所有元素</td></tr><tr><td align="center">boolean</td><td align="center">retainAll(Collection c)</td><td align="center">保留当前集合中与指定集合相同的所有元素</td></tr></tbody></table><h3 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h3><p>具有映射关系“key-value对”的集合</p><hr><h2 id="List集合"><a href="#List集合" class="headerlink" title="List集合"></a>List集合</h2><h4 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h4><p>List集合接口，也称之为线性表，是一个<strong>有序列表</strong>。</p><p>集合中的元素是顺序存储，可以通过下标访问。</p><p>List集合中<strong>允许出现重复元素</strong>。</p><p>实现List集合接口的常用类：ArrayList、LinkedList、Vector和Stack</p><h4 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h4><table><thead><tr><th align="center">类型</th><th align="center">方法名</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">boolean</td><td align="center">add(E e)</td><td align="center">把元素e加到表的尾部</td></tr><tr><td align="center">void</td><td align="center">add(int index,E e)</td><td align="center">把元素e加到表的index位置，原位置元素后移</td></tr><tr><td align="center">boolean</td><td align="center">equals(Object obj)</td><td align="center">比较对象o是否与表中的元素是同一元素</td></tr><tr><td align="center">E</td><td align="center">get(int index)</td><td align="center">得到表中index位置的元素</td></tr><tr><td align="center">int</td><td align="center">indexOf(Object o)</td><td align="center">判断元素o是否存在，若不则返回-1</td></tr><tr><td align="center">Iteratot<e></e></td><td align="center">iterator()</td><td align="center">获得表的遍历器</td></tr><tr><td align="center">E</td><td align="center">set(int index,E e)</td><td align="center">修改位置上的元素</td></tr></tbody></table><h3 id="ArrayList集合类"><a href="#ArrayList集合类" class="headerlink" title="ArrayList集合类"></a>ArrayList集合类</h3><p>使用数组方式实现List接口</p><p>检索效率很高</p><p>删除效率很低</p><p>即数据结构的顺序表</p><h4 id="主要方法-1"><a href="#主要方法-1" class="headerlink" title="主要方法"></a>主要方法</h4><table><thead><tr><th align="center">类型</th><th align="center">方法名</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center"></td><td align="center">ArrayList()</td><td align="center">构造一个初始容量为10的空列表</td></tr><tr><td align="center"></td><td align="center">ArrayList(Collection c)</td><td align="center">构造一个包含指定collectiong的元素列表</td></tr><tr><td align="center"></td><td align="center">ArrayList(int capacity)</td><td align="center">构造一个具有指定初始容量的空列表</td></tr><tr><td align="center">Boolean</td><td align="center">add(E e)</td><td align="center">把元素e加到表的尾部</td></tr><tr><td align="center">E</td><td align="center">get(int index)</td><td align="center">得到表中index位置的元素</td></tr><tr><td align="center">boolean</td><td align="center">indexOf(Object o)</td><td align="center">判断元素o是否存在，若不则返回-1</td></tr><tr><td align="center">Iterator<e></e></td><td align="center">iterator</td><td align="center">获得表的遍历器</td></tr></tbody></table><pre class="line-numbers language-none"><code class="language-none">import java.util.ArrayList;import java.util.Scanner;public class Main {public static void main(String[] args) {ArrayList&lt;Integer&gt; list =new ArrayList&lt;Integer&gt;();  list.add(1);  list.add(3);  list.add(5);  list.add(7);  for (int i=0;i&lt;list.size();i++){      System.out.print(list.get(i)+",");  }  System.out.println();  list.remove(0);  System.out.println("The second item = " + list.get(1));}}运行结果：1，3，5，7The seconditem = 5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="LinkedList集合类"><a href="#LinkedList集合类" class="headerlink" title="LinkedList集合类"></a>LinkedList集合类</h3><p>使用<strong>双向</strong>链表方式实现List接口，以及队列Deque接口</p><p>删除效率很高</p><p>检索效率很低</p><p>表示线性序列表，也可以表示堆栈使用，还可以当做队列使用。</p><h4 id="主要方法-2"><a href="#主要方法-2" class="headerlink" title="主要方法"></a>主要方法</h4><table><thead><tr><th align="center">类型</th><th align="center">方法名</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center"></td><td align="center">LinkedList()</td><td align="center">构造一个初始容量为 10 的空列表</td></tr><tr><td align="center"></td><td align="center">LinkedList(Collection c)</td><td align="center">构造一个包含指定 collection 的元素的列表</td></tr><tr><td align="center">void</td><td align="center">aa(int index,E element)</td><td align="center">把元素e插入到列表index所指位置，并依次后移</td></tr><tr><td align="center">boolean</td><td align="center">add(E e)</td><td align="center">把元素e加到表的尾部</td></tr><tr><td align="center">boolean</td><td align="center">indexOf(Object o)</td><td align="center">判断元素o在表中是否存在。若不存在，则返回-1</td></tr><tr><td align="center">void</td><td align="center">addFirst(E e)</td><td align="center">将元素e插入到列表的头部</td></tr><tr><td align="center">E</td><td align="center">getFirst()</td><td align="center">返回列表的头部元素</td></tr><tr><td align="center">E</td><td align="center">removeFirst</td><td align="center">从列表中删除头部元素并返回该元素</td></tr><tr><td align="center">E</td><td align="center">pop()</td><td align="center">栈顶元素出栈</td></tr><tr><td align="center">void</td><td align="center">push(E e)</td><td align="center">元素e入栈</td></tr></tbody></table><pre class="line-numbers language-none"><code class="language-none">import java.util.ArrayList;import java.util.LinkedList;import java.util.Scanner;public class Main {public static void main(String[] args) {LinkedList&lt;String&gt; list = new LinkedList&lt;String&gt;();list.add("A");list.add("B");list.add("C");list.add("D");list.remove("C");list.addFirst("E");for(String s : list) {    System.out.println(s); }//foreach遍历}}运行结果：EABD<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="Vector集合类"><a href="#Vector集合类" class="headerlink" title="Vector集合类"></a>Vector集合类</h3><p>是一种<strong>动态</strong>数组，元素只能是对象</p><p>对象类型可以不同</p><p>与ArrayList、LinkedList相比，<strong>线程安全</strong></p><p>通过<strong>synchronized</strong>关键字修饰方法，实现线程安全</p><table><thead><tr><th align="center">类型</th><th align="center">方法名</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center"></td><td align="center">Vector()</td><td align="center">构造一个初始容量为 10 的空列表</td></tr><tr><td align="center"></td><td align="center">Vector(Collection c)</td><td align="center">构造一个包含指定 collection 的元素的列表</td></tr><tr><td align="center">boolean</td><td align="center">add(E e)</td><td align="center">把元素e加到表的尾部</td></tr><tr><td align="center">int</td><td align="center">indexOf(Object o)</td><td align="center">判断元素o在表中是否存在。若不存在，则返回-1</td></tr><tr><td align="center">synchronized void</td><td align="center">addElement(E obj)</td><td align="center">将元素e同步插入到列表的尾部</td></tr><tr><td align="center">synchronized void</td><td align="center">removeElement(Object obj)</td><td align="center">同步删除元素obj</td></tr><tr><td align="center">synchronized void</td><td align="center">insertElementAt(E obj,int index)</td><td align="center">在index位置同步插入元素obj</td></tr><tr><td align="center">synchronized void</td><td align="center">firstElement()</td><td align="center">同步返回第一个元素</td></tr></tbody></table><pre class="line-numbers language-none"><code class="language-none">import java.util.ArrayList;import java.util.LinkedList;import java.util.Scanner;import java.util.Vector;public class Main {public static void main(String[] args) {Vector v = new Vector();v.add("Hello");v.add("JDK");v.addElement(8.0);        for(int i = 0; i &lt; v.size();i++){    System.out.println(v.get(i));}}}运行结果：HelloJDK8.0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="Set集合"><a href="#Set集合" class="headerlink" title="Set集合"></a>Set集合</h2><p>Set集合中元素<strong>无序，不重复</strong></p><p>方法与Collection相同</p><p>实现Set集合接口的类：HashSet、TreeSet</p><hr><h4 id="主要方法-3"><a href="#主要方法-3" class="headerlink" title="主要方法"></a>主要方法</h4><p><a href="https://imgtu.com/i/H9ywfs"><img src="https://s4.ax1x.com/2022/01/30/H9ywfs.png" alt="H9ywfs.png"></a></p><hr><h3 id="HashSet集合类"><a href="#HashSet集合类" class="headerlink" title="HashSet集合类"></a>HashSet集合类</h3><p>集合中元素<strong>无序</strong></p><p>元素<strong>不重复</strong></p><p>元素<strong>值</strong>可以为<strong>空（null）</strong></p><p>存储每个元素时会生成一个唯一的整数标识——<strong>散列码</strong>（hash code），HashSet根据散列码来决定元素所在的存储位置</p><hr><h4 id="主要方法-4"><a href="#主要方法-4" class="headerlink" title="主要方法"></a>主要方法</h4><p><a href="https://imgtu.com/i/H9yBpn"><img src="https://s4.ax1x.com/2022/01/30/H9yBpn.png" alt="H9yBpn.png"></a></p><hr><pre class="line-numbers language-none"><code class="language-none">import java.util.HashSet;import java.util.Iterator;public class Main {public static void main(String[] args) {HashSet&lt;String&gt; set = new HashSet&lt;String&gt;();set.add("one");set.add("two");set.add("tree");set.add("one");//set中存放one,two,three,且无序不重复System.out.println(set.size());Iterator&lt;String&gt; iterator = set.iterator();while(iterator.hasNext()){    System.out.println(iterator.next());}}}运行结果：3onetreetwo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="TreeSet集合类"><a href="#TreeSet集合类" class="headerlink" title="TreeSet集合类"></a>TreeSet集合类</h3><p>集合中元素<strong>有序</strong>：采用<strong>二叉搜索树</strong>的数据结构进行元素的存储，按照树形层次排列，会按其存放的数据的“大小”顺序一层一层地依次排列</p><p>元素<strong>不重复</strong></p><p>存储的元素类型必须是<strong>可排序</strong>的</p><hr><h4 id="主要方法-5"><a href="#主要方法-5" class="headerlink" title="主要方法"></a>主要方法</h4><p><a href="https://imgtu.com/i/H9yfh9"><img src="https://s4.ax1x.com/2022/01/30/H9yfh9.png" alt="H9yfh9.png"></a></p><pre class="line-numbers language-none"><code class="language-none">import java.util.Iterator;import java.util.TreeSet;public class Main {public static void main(String[] args) {TreeSet&lt;String&gt; treeSet = new TreeSet&lt;String&gt;();treeSet.add("banana");treeSet.add("peach");treeSet.add("pineapple");treeSet.add("apple");  System.out.println(treeSet.first());System.out.println(treeSet.last());Iterator&lt;String&gt; iterator = treeSet.iterator();while(iterator.hasNext()){   System.out.println(iterator.next());}}}运行结果：applepineappleapplebananapeachpineapple<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="Map集合"><a href="#Map集合" class="headerlink" title="Map集合"></a>Map集合</h2><p>用于存放一组成对的<strong>“键值对”</strong>对象</p><p>每个元素包括两部分：<strong>键（key）</strong>、<strong>值（value）</strong></p><p><strong>键（key）不能重复</strong>，<strong>值（value）可以重复</strong></p><p>实现Set集合接口的类：HashMap、HashTree、HashTable</p><hr><h4 id="主要方法-6"><a href="#主要方法-6" class="headerlink" title="主要方法"></a>主要方法</h4><p><a href="https://imgtu.com/i/H9yWtJ"><img src="https://s4.ax1x.com/2022/01/30/H9yWtJ.png" alt="H9yWtJ.png"></a></p><p><a href="https://imgtu.com/i/H9yRk4"><img src="https://s4.ax1x.com/2022/01/30/H9yRk4.png" alt="H9yRk4.png"></a></p><hr><h3 id="HashMap集合类"><a href="#HashMap集合类" class="headerlink" title="HashMap集合类"></a>HashMap集合类</h3><p>采用散列表数据结构存储数据</p><p>key-value存储</p><p>键（key）不能重复，值（value）可以重复</p><h4 id="主要方法-7"><a href="#主要方法-7" class="headerlink" title="主要方法"></a>主要方法</h4><p><a href="https://imgtu.com/i/H9yOtH"><img src="https://s4.ax1x.com/2022/01/30/H9yOtH.png" alt="H9yOtH.png"></a></p><h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><hr><h2 id="系统类"><a href="#系统类" class="headerlink" title="系统类"></a>系统类</h2><hr><h2 id="其他常用类"><a href="#其他常用类" class="headerlink" title="其他常用类"></a>其他常用类</h2>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
